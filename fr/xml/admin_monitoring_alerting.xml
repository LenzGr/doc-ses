<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_monitoring_alerting.xml" version="5.0" xml:id="monitoring-alerting">
 <title>Surveillance et alertes</title>
 <para>
  Dans SUSE Enterprise Storage 6, DeepSea ne déploie plus une pile de surveillance et d'alertes sur Salt Master. Les utilisateurs doivent définir le rôle Prometheus pour Prometheus et Alertmanager, et le rôle Grafana pour Grafana. Lorsque le rôle Prometheus ou Grafana est assigné à plusieurs noeuds, une configuration hautement disponible est déployée.
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">Prometheus</emphasis> est le toolkit de surveillance et d'alerte.
   </para>
 </listitem>
 <listitem>
  <para>
   <emphasis role="bold">Alertmanager</emphasis> gère les alertes envoyées par le serveur Prometheus.
  </para>
 </listitem>
  <listitem>
   <para>
    <emphasis role="bold">Grafana</emphasis> est le logiciel de visualisation et d'alerte.
   </para>
  </listitem>
  <listitem>
   <para>
    <systemitem class="daemon">prometheus-node_exporter</systemitem> est le service qui s'exécute sur tous les minions Salt.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  La configuration Prometheus et les cibles de <emphasis>scraping</emphasis> (daemons d'exportation) sont configurées automatiquement par DeepSea. DeepSea déploie également une liste d'alertes par défaut, par exemple <literal>health error</literal> (erreur de santé), <literal>10% OSDs down</literal> (10 % OSD arrêtés) ou <literal>pgs inactive</literal> (GP inactifs).
 </para>

 <sect1 xml:id="pillar-variables">
  <title>Variables Pillar</title>
  <para>L'interface Pillar de Salt est un magasin de paires clé-valeur qui fournit des informations et des valeurs de configuration aux minions. Il est disponible pour tous les minions, chaque fois avec un contenu différent. L'interface Pillar de Salt est préremplie avec des valeurs par défaut et peut être personnalisée de deux façons différentes :</para>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/global.yml</filename></emphasis> : pour changer les variables Pillar pour tous les noeuds.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/<replaceable>NOM_GRAPPE</replaceable>/minions/<replaceable>HOST</replaceable></filename></emphasis> : pour changer des configurations de minions spécifiques.
     </para>
    </listitem>
   </itemizedlist>
  <para>
    Les variables Pillar ci-dessous sont disponibles pour tous les noeuds par défaut :
  </para>
<screen>
  monitoring:
  alertmanager:
    config: salt://path/to/config
    additional_flags: ''
  grafana:
    ssl_cert: False # self-signed certs are created by default
    ssl_key: False # self-signed certs are created by default
  prometheus:
    # pass additional configration to prometheus
    additional_flags: ''
    alert_relabel_config: []
    rule_files: []
    # per exporter config variables
    scrape_interval:
      ceph: 10
      node_exporter: 10
      prometheus: 10
      grafana: 10
    relabel_config:
      alertmanager: []
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    metric_relabel_config:
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    target_partition:
      ceph: '1/1'
      node_exporter: '1/1'
      prometheus: '1/1'
      grafana: '1/1'
</screen>
</sect1>

<sect1 xml:id="grafana">
  <title>Grafana</title>
  <para>
    Tout le trafic est chiffré via Grafana. Vous pouvez fournir vos propres certificats SSL ou créer un certificat auto-signé.</para>
  <para>Grafana utilise les variables suivantes :</para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_cert</literal></emphasis>
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_key</literal></emphasis>
      </para>
    </listitem>
  </itemizedlist>
  <para>Pour plus d'informations sur la fourniture de vos propres certificats SSL, reportez-vous à la <xref linkend="cert-sign-CA"/> ou pour créer votre propre certificat, à la <xref linkend="self-sign-certificates"/>.
  </para>
</sect1>

 <sect1 xml:id="prometheus">
   <title>Prometheus</title>
  <para>Il s'agit de la configuration basée sur l'exportateur qui peut être transmise à l'interface Pillar. Ces groupes effectuent une assignation vers les exportateurs qui fournissent des données. L'exportateur de noeud est présent sur tous les noeuds. Ceph est exporté par les noeuds Ceph Manager ; Prometheus et Grafana sont exportés par les noeuds Prometheus et Grafana respectifs.</para>
  <para>Prometheus utilise les variables suivantes :</para>
    <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><literal>scrape_interval</literal></emphasis> : permet de changer l'intervalle de scraping, autrement dit la fréquence à laquelle les données d'un exportateur doivent être récupérées.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>target_partition</literal></emphasis> : permet de partitionner des cibles de scraping lorsque plusieurs instances Prometheus sont déployées et que certaines instances ne scrapent qu'une partie de toutes les instances d'exportateur.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>relabel_config</literal></emphasis> : réécrit dynamiquement l'ensemble d'étiquettes d'une cible avant qu'elle soit scrapée. Plusieurs étapes de réétiquetage peuvent être définies par configuration de scraping.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>metrics_relabel_config</literal></emphasis> : appliquée aux exemples en tant que dernière étape avant l'ingestion.
     </para>
    </listitem>
   </itemizedlist>
 </sect1>

 <sect1 xml:id="alerting-alertmanager">
  <title>Alertmanager</title>
  <para>
   Alertmanager gère les alertes envoyées par le serveur Prometheus. Il s'occupe de les dédupliquer, de les regrouper et de les acheminer vers le bon récepteur. Il se charge également de mettre les alertes en sourdine. Alertmanager est configuré via les indicateurs de ligne de commande et un fichier de configuration qui définit les règles d'inhibition, le routage des notifications et les récepteurs de ces dernières.
  </para>
  <sect2>
   <title>Fichier de configuration</title>
   <para>
    La configuration d'Alertmanager est différente pour chaque déploiement. Par conséquent, DeepSea ne fournit aucune valeur par défaut associée. Vous devez déterminer votre propre fichier de configuration <filename>alertmanager.yml</filename>. Le paquetage
    <package>alertmanager</package> par défaut installe un fichier de configuration <filename>/etc/prometheus/alertmanager.yml</filename> qui peut servir de configuration d'exemple. Si vous préférez que votre configuration Alertmanager soit gérée par DeepSea, ajoutez la clé suivante à Pillar, par exemple au fichier <filename>/srv/pillar/ceph/ceph/stack/ceph/minions/<replaceable>ID_MINION_SALT_MASTER</replaceable>.sls</filename> :
   </para>
   <para>
    Pour un exemple complet du fichier de configuration d'Alertmanager, reportez-vous à l'<xref linkend="app-alerting-default"/>.
   </para>
<screen>
monitoring:
 alertmanager_config:
   /path/to/your/alertmanager/config.yml
</screen>
   <para>
    Le fichier de configuration d'Alertmanager est écrit au format YAML. Il suit le schéma décrit ci-dessous. Les paramètres entre parenthèses sont facultatifs. Pour les paramètres non listés, la valeur par défaut est utilisée. Les marques de réservation génériques suivantes sont utilisés dans le modèle :
   </para>
   <variablelist>
    <varlistentry>
     <term><replaceable>DURATION</replaceable></term>
     <listitem>
      <para>
       Durée correspondant à l'expression régulière <literal>[0-9]+(ms|[smhdwy])</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELNAME</replaceable></term>
     <listitem>
      <para>
       Chaîne correspondant à l'expression régulière <literal>[a-zA-Z_][a-zA-Z0-9_]*</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELVALUE</replaceable></term>
     <listitem>
      <para>
       Chaîne de caractères Unicode.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>FILEPATH</replaceable></term>
     <listitem>
      <para>
       Chemin valide dans le répertoire de travail actuel.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>BOOLEAN</replaceable></term>
     <listitem>
      <para>
       Attribut booléen pouvant prendre les valeurs « true » ou « false ».
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>STRING</replaceable></term>
     <listitem>
      <para>
       Chaîne régulière.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>SECRET</replaceable></term>
     <listitem>
      <para>
       Chaîne régulière qui est un secret, par exemple un mot de passe.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_STRING</replaceable></term>
     <listitem>
      <para>
       Chaîne étendue par modèle avant utilisation.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_SECRET</replaceable></term>
     <listitem>
      <para>
       Chaîne secrète étendue par modèle avant utilisation.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <example>
    <title>configuration globale</title>
    <para>
     Les paramètres de la configuration <literal>global:</literal> sont valides dans tous les autres contextes de configuration. Ils servent également de valeurs par défaut pour d'autres sections de configuration.
    </para>
<screen>
global:
# the time after which an alert is declared resolved if it has not been updated
[ resolve_timeout: <replaceable>DURATION</replaceable> | default = 5m ]

# The default SMTP From header field.
[ smtp_from: <replaceable>TMPL_STRING</replaceable> ]
# The default SMTP smarthost used for sending emails, including port number.
# Port number usually is 25, or 587 for SMTP over TLS
# (sometimes referred to as STARTTLS).
# Example: smtp.example.org:587
[ smtp_smarthost: <replaceable>STRING</replaceable> ]
# The default host name to identify to the SMTP server.
[ smtp_hello: <replaceable>STRING</replaceable> | default = "localhost" ]
[ smtp_auth_username: <replaceable>STRING</replaceable> ]
# SMTP Auth using LOGIN and PLAIN.
[ smtp_auth_password: <replaceable>SECRET</replaceable> ]
# SMTP Auth using PLAIN.
[ smtp_auth_identity: <replaceable>STRING</replaceable> ]
# SMTP Auth using CRAM-MD5.
[ smtp_auth_secret: <replaceable>SECRET</replaceable> ]
# The default SMTP TLS requirement.
[ smtp_require_tls: <replaceable>BOOL</replaceable> | default = true ]

# The API URL to use for Slack notifications.
[ slack_api_url: <replaceable>STRING</replaceable> ]
[ victorops_api_key: <replaceable>STRING</replaceable> ]
[ victorops_api_url: <replaceable>STRING</replaceable> | default = "https://victorops.example.com/integrations/alert/" ]
[ pagerduty_url: <replaceable>STRING</replaceable> | default = "https://pagerduty.example.com/v2/enqueue" ]
[ opsgenie_api_key: <replaceable>STRING</replaceable> ]
[ opsgenie_api_url: <replaceable>STRING</replaceable> | default = "https://opsgenie.example.com/" ]
[ hipchat_api_url: <replaceable>STRING</replaceable> | default = "https://hipchat.example.com/" ]
[ hipchat_auth_token: <replaceable>SECRET</replaceable> ]
[ wechat_api_url: <replaceable>STRING</replaceable> | default = "https://wechat.example.com/cgi-bin/" ]
[ wechat_api_secret: <replaceable>SECRET</replaceable> ]
[ wechat_api_corp_id: <replaceable>STRING</replaceable> ]

# The default HTTP client configuration
[ http_config: <replaceable>HTTP_CONFIG</replaceable> ]

# Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - <replaceable>FILEPATH</replaceable> ... ]

# The root node of the routing tree.
route: <replaceable>ROUTE</replaceable>

# A list of notification receivers.
receivers:
- <replaceable>RECEIVER</replaceable> ...

# A list of inhibition rules.
inhibit_rules:
[ - <replaceable>INHIBIT_RULE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>ROUTE</replaceable></title>
    <para>
     Un bloc <replaceable>ROUTE</replaceable> définit un noeud dans une arborescence de routage. Les paramètres non spécifiés sont hérités de son noeud parent. Chaque alerte entre dans l'arborescence de routage au niveau de la route de niveau supérieur configurée, qui doit correspondre à toutes les alertes. Elle traverse ensuite les noeuds enfants. Si l'option <option>continue</option> est définie sur « false », la traversée s'arrête après le premier enfant correspondant. Si l'option est définie sur « true » sur un noeud correspondant, l'alerte continuera d'établir la correspondance avec les frères suivants. Si une alerte ne correspond pas à aucun enfant d'un noeud, elle est traitée en fonction des paramètres de configuration du noeud actuel.
    </para>
<screen>
[ receiver: <replaceable>STRING</replaceable> ]
[ group_by: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]

# If an alert should continue matching subsequent sibling nodes.
[ continue: <replaceable>BOOLEAN</replaceable> | default = false ]

# A set of equality matchers an alert has to fulfill to match a node.
match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]

# A set of regex-matchers an alert has to fulfill to match a node.
match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Time to wait before sending a notification for a group of alerts.
[ group_wait: <replaceable>DURATION</replaceable> | default = 30s ]

# Time to wait before sending a notification about new alerts
# added to a group of alerts for which an initial notification has
# already been sent.
[ group_interval: <replaceable>DURATION</replaceable> | default = 5m ]

# Time to wait before re-sending a notification
[ repeat_interval: <replaceable>DURATION</replaceable> | default = 4h ]

# Possible child routes.
routes:
 [ - <replaceable>ROUTE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>INHIBIT_RULE</replaceable></title>
    <para>
     Une règle d'inhibition met en sourdine une alerte cible qui concorde à un ensemble de correspondances lorsqu'il existe une alerte source qui concorde avec un autre ensemble de correspondances. Les deux alertes doivent partager les mêmes valeurs d'étiquette pour les noms d'étiquette dans la liste <option>equal</option>.
    </para>
    <para>
     Les alertes peuvent concorder et donc s'inhiber. N'écrivez pas de règles d'inhibition lorsqu'une alerte correspond à la fois à la source et à la cible.
    </para>
<screen>
# Matchers that need to be fulfilled for the alerts to be muted.
target_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
target_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Matchers for which at least one alert needs to exist so that the
# inhibition occurs.
source_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
source_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Labels with an equal value in the source and target
# alert for the inhibition to take effect.
[ equal: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]
</screen>
   </example>
   <example>
    <title><replaceable>HTTP_CONFIG</replaceable></title>
    <para>
     <replaceable>HTTP_CONFIG</replaceable> configure le client HTTP utilisé par le récepteur pour communiquer avec les services API.
    </para>
    <para>
     Notez que les options <option>basic_auth</option>, <option>bearer_token</option> et <option>bearer_token_file</option> s'excluent mutuellement.
    </para>
<screen>
# Sets the 'Authorization' header with the user name and password.
basic_auth:
[ username: <replaceable>STRING</replaceable> ]
[ password: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token.
[ bearer_token: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token read from a file.
[ bearer_token_file: <replaceable>FILEPATH</replaceable> ]

# TLS settings.
tls_config:
# CA certificate to validate the server certificate with.
[ ca_file: <replaceable>FILEPATH</replaceable> ]
# Certificate and key files for client cert authentication to the server.
[ cert_file: <replaceable>FILEPATH</replaceable> ]
[ key_file: <replaceable>FILEPATH</replaceable> ]
# ServerName extension to indicate the name of the server.
# http://tools.ietf.org/html/rfc4366#section-3.1
[ server_name: <replaceable>STRING</replaceable> ]
# Disable validation of the server certificate.
[ insecure_skip_verify: <replaceable>BOOLEAN</replaceable> | default = false]

# Optional proxy URL.
[ proxy_url: <replaceable>STRING</replaceable> ]
</screen>
   </example>
   <example>
    <title><replaceable>RECEIVER</replaceable></title>
    <para>
     Le récepteur (Receiver) est une configuration nommée pour une ou plusieurs intégrations de notification.
    </para>
    <para>
     Au lieu d'ajouter de nouveaux récepteurs, nous recommandons d'implémenter des intégrations de notification personnalisées à l'aide du récepteur Webhook (voir <xref linkend="alert-webhook"/>).
    </para>
<screen>
# The unique name of the receiver.
name: <replaceable>STRING</replaceable>

# Configurations for several notification integrations.
email_configs:
[ - <replaceable>EMAIL_CONFIG</replaceable>, ... ]
hipchat_configs:
[ - <replaceable>HIPCHAT_CONFIG</replaceable>, ... ]
pagerduty_configs:
[ - <replaceable>PAGERDUTY_CONFIG</replaceable>, ... ]
pushover_configs:
[ - <replaceable>PUSHOVER_CONFIG</replaceable>, ... ]
slack_configs:
[ - <replaceable>SLACK_CONFIG</replaceable>, ... ]
opsgenie_configs:
[ - <replaceable>OPSGENIE_CONFIG</replaceable>, ... ]
webhook_configs:
[ - <replaceable>WEBHOOK_CONFIG</replaceable>, ... ]
victorops_configs:
[ - <replaceable>VICTOROPS_CONFIG</replaceable>, ... ]
wechat_configs:
[ - <replaceable>WECHAT_CONFIG</replaceable>, ... ]
</screen>
   </example>
   <example>
    <title><replaceable>EMAIL_CONFIG</replaceable></title>
<screen>
# Whether to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The email address to send notifications to.
to: <replaceable>TMPL_STRING</replaceable>

# The sender address.
[ from: <replaceable>TMPL_STRING</replaceable> | default = global.smtp_from ]

# The SMTP host through which emails are sent.
[ smarthost: <replaceable>STRING</replaceable> | default = global.smtp_smarthost ]

# The host name to identify to the SMTP server.
[ hello: <replaceable>STRING</replaceable> | default = global.smtp_hello ]

# SMTP authentication details.
[ auth_username: <replaceable>STRING</replaceable> | default = global.smtp_auth_username ]
[ auth_password: <replaceable>SECRET</replaceable> | default = global.smtp_auth_password ]
[ auth_secret: <replaceable>SECRET</replaceable> | default = global.smtp_auth_secret ]
[ auth_identity: <replaceable>STRING</replaceable> | default = global.smtp_auth_identity ]

# The SMTP TLS requirement.
[ require_tls: <replaceable>BOOL</replaceable> | default = global.smtp_require_tls ]

# The HTML body of the email notification.
[ html: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "email.default.html" . }}' ]
# The text body of the email notification.
[ text: <replaceable>TMPL_STRING</replaceable> ]

# Further headers email header key/value pairs. Overrides any headers
# previously set by the notification implementation.
[ headers: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]
</screen>
   </example>
   <example>
    <title><replaceable>HIPCHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The HipChat Room ID.
room_id: <replaceable>TMPL_STRING</replaceable>
# The authentication token.
[ auth_token: <replaceable>SECRET</replaceable> | default = global.hipchat_auth_token ]
# The URL to send API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.hipchat_api_url ]

# A label to be shown in addition to the sender's name.
[ from:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.from" . }}' ]
# The message body.
[ message:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.message" . }}' ]
# Whether this message will trigger a user notification.
[ notify:  <replaceable>BOOLEAN</replaceable> | default = false ]
# Determines how the message is treated by the alertmanager and rendered inside HipChat. Valid values are 'text' and 'html'.
[ message_format:  <replaceable>STRING</replaceable> | default = 'text' ]
# Background color for message.
[ color:  <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}red{{ else }}green{{ end }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PAGERDUTY_CONFIG</replaceable></title>
    <para>
     Les options <option>routing_key</option> et <option>service_key</option> s'excluent mutuellement.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The PagerDuty integration key (when using 'Events API v2').
routing_key: <replaceable>TMPL_SECRET</replaceable>
# The PagerDuty integration key (when using 'Prometheus').
service_key: <replaceable>TMPL_SECRET</replaceable>

# The URL to send API requests to.
[ url: <replaceable>STRING</replaceable> | default = global.pagerduty_url ]

# The client identification of the Alertmanager.
[ client:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.client" . }}' ]
# A backlink to the notification sender.
[ client_url:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.clientURL" . }}' ]

# The incident description.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.description" .}}' ]

# Severity of the incident.
[ severity: <replaceable>TMPL_STRING</replaceable> | default = 'error' ]

# A set of arbitrary key/value pairs that provide further details.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } | default = {
 firing:       '{{ template "pagerduty.default.instances" .Alerts.Firing }}'
 resolved:     '{{ template "pagerduty.default.instances" .Alerts.Resolved }}'
 num_firing:   '{{ .Alerts.Firing | len }}'
 num_resolved: '{{ .Alerts.Resolved | len }}'
} ]

# The HTTP client's configuration.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PUSHOVER_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The recipient user key.
user_key: <replaceable>SECRET</replaceable>

# Registered application’s API token.
token: <replaceable>SECRET</replaceable>

# Notification title.
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.title" . }}' ]

# Notification message.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.message" . }}' ]

# A supplementary URL displayed together with the message.
[ url: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.url" . }}' ]

# Priority.
[ priority: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}2{{ else }}0{{ end }}' ]

# How often the Pushover servers will send the same notification (at least 30 seconds).
[ retry: <replaceable>DURATION</replaceable> | default = 1m ]

# How long your notification will continue to be retried (unless the user
# acknowledges the notification).
[ expire: <replaceable>DURATION</replaceable> | default = 1h ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The Slack webhook URL.
[ api_url: <replaceable>SECRET</replaceable> | default = global.slack_api_url ]

# The channel or user to send notifications to.
channel: <replaceable>TMPL_STRING</replaceable>

# API request data as defined by the Slack webhook API.
[ icon_emoji: <replaceable>TMPL_STRING</replaceable> ]
[ icon_url: <replaceable>TMPL_STRING</replaceable> ]
[ link_names: <replaceable>BOOLEAN</replaceable> | default = false ]
[ username: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.username" . }}' ]
# The following parameters define the attachment.
actions:
[ <replaceable>ACTION_CONFIG</replaceable> ... ]
[ color: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}danger{{ else }}good{{ end }}' ]
[ fallback: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.fallback" . }}' ]
fields:
[ <replaceable>FIELD_CONFIG</replaceable> ... ]
[ footer: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.footer" . }}' ]
[ pretext: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.pretext" . }}' ]
[ short_fields: <replaceable>BOOLEAN</replaceable> | default = false ]
[ text: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.text" . }}' ]
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.title" . }}' ]
[ title_link: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.titlelink" . }}' ]
[ image_url: <replaceable>TMPL_STRING</replaceable> ]
[ thumb_url: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>ACTION_CONFIG</replaceable> pour <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Provide a button to tell Slack you want to render a button.
type: <replaceable>TMPL_STRING</replaceable>
# Label for the button.
text: <replaceable>TMPL_STRING</replaceable>
# http or https URL to deliver users to. If you specify invalid URLs, the message will be posted with no button.
url: <replaceable>TMPL_STRING</replaceable>
#  If set to 'primary', the button will be green, indicating the best forward action to take
#  'danger' turns the button red, indicating a destructive action.
[ style: <replaceable>TMPL_STRING</replaceable> [ default = '' ]
</screen>
   </example>
   <example>
    <title><replaceable>FIELD_CONFIG</replaceable> pour <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# A bold heading without markup above the <option>value</option> text.
title: <replaceable>TMPL_STRING</replaceable>
# The text of the field. It can span across several lines.
value: <replaceable>TMPL_STRING</replaceable>
# A flag indicating if <option>value</option> is short enough to be displayed together with other values.
[ short: <replaceable>BOOLEAN</replaceable> | default = slack_config.short_fields ]
</screen>
   </example>
   <example>
    <title><replaceable>OPSGENIE_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key to use with the OpsGenie API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.opsgenie_api_key ]

# The host to send OpsGenie API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.opsgenie_api_url ]

# Alert text (maximum is 130 characters).
[ message: <replaceable>TMPL_STRING</replaceable> ]

# A description of the incident.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.description" . }}' ]

# A backlink to the sender.
[ source: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.source" . }}' ]

# A set of arbitrary key/value pairs that provide further detail.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]

# Comma separated list of team responsible for notifications.
[ teams: <replaceable>TMPL_STRING</replaceable> ]

# Comma separated list of tags attached to the notifications.
[ tags: <replaceable>TMPL_STRING</replaceable> ]

# Additional alert note.
[ note: <replaceable>TMPL_STRING</replaceable> ]

# Priority level of alert, one of P1, P2, P3, P4, and P5.
[ priority: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>VICTOROPS_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key for talking to the VictorOps API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.victorops_api_key ]

# The VictorOps API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.victorops_api_url ]

# A key used to map the alert to a team.
routing_key: <replaceable>TMPL_STRING</replaceable>

# Describes the behavior of the alert (one of 'CRITICAL', 'WARNING', 'INFO').
[ message_type: <replaceable>TMPL_STRING</replaceable> | default = 'CRITICAL' ]

# Summary of the alerted problem.
[ entity_display_name: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.entity_display_name" . }}' ]

# Long explanation of the alerted problem.
[ state_message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.state_message" . }}' ]

# The monitoring tool the state message is from.
[ monitoring_tool: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.monitoring_tool" . }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example xml:id="alert-webhook">
    <title><replaceable>WEBHOOK_CONFIG</replaceable></title>
    <para>
     Vous pouvez utiliser le récepteur Webhook pour configurer un récepteur générique.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The endpoint for sending HTTP POST requests.
url: <replaceable>STRING</replaceable>

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
    <para>
     Alertmanager envoie des requêtes HTTP POST au format JSON suivant :
    </para>
<screen>
{
 "version": "4",
 "groupKey": <replaceable>STRING</replaceable>, // identifycation of the group of alerts (to deduplicate)
 "status": "&lt;resolved|firing&gt;",
 "receiver": <replaceable>STRING</replaceable>,
 "groupLabels": <replaceable>OBJECT</replaceable>,
 "commonLabels": <replaceable>OBJECT</replaceable>,
 "commonAnnotations": <replaceable>OBJECT</replaceable>,
 "externalURL": <replaceable>STRING</replaceable>, // backlink to Alertmanager.
 "alerts": [
   {
     "status": "&lt;resolved|firing&gt;",
     "labels": <replaceable>OBJECT</replaceable>,
     "annotations": <replaceable>OBJECT</replaceable>,
     "startsAt": "&lt;rfc3339&gt;",
     "endsAt": "&lt;rfc3339&gt;",
     "generatorURL": <replaceable>STRING</replaceable> // identifies the entity that caused the alert
   },
   ...
 ]
}
</screen>
    <para>
     Le récepteur Webhook permet l'intégration avec les mécanismes de notification suivants :
    </para>
    <itemizedlist>
     <listitem>
      <para>
       DingTalk (https://github.com/timonwong/prometheus-webhook-dingtalk)
      </para>
     </listitem>
     <listitem>
      <para>
       IRC Bot (https://github.com/multimfi/bot)
      </para>
     </listitem>
     <listitem>
      <para>
       JIRAlert (https://github.com/free/jiralert)
      </para>
     </listitem>
     <listitem>
      <para>
       Phabricator / Maniphest (https://github.com/knyar/phalerts)
      </para>
     </listitem>
     <listitem>
      <para>
       Prom2teams : transmet des notifications à Microsoft Teams (https://github.com/idealista/prom2teams)
      </para>
     </listitem>
     <listitem>
      <para>
       SMS : prend en charge plusieurs fournisseurs (https://github.com/messagebird/sachet)
      </para>
     </listitem>
     <listitem>
      <para>
       Bot de télégramme (https://github.com/inCaller/prometheus_bot)
      </para>
     </listitem>
     <listitem>
      <para>
       Trappe SNMP (https://github.com/SUSE/prometheus-webhook-snmp)
      </para>
     </listitem>
    </itemizedlist>
   </example>
   <example>
    <title><replaceable>WECHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The API key to use for the WeChat API.
[ api_secret: <replaceable>SECRET</replaceable> | default = global.wechat_api_secret ]

# The WeChat API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.wechat_api_url ]

# The corp id used to authenticate.
[ corp_id: <replaceable>STRING</replaceable> | default = global.wechat_api_corp_id ]

# API request data as defined by the WeChat API.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "wechat.default.message" . }}' ]
[ agent_id: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.agent_id" . }}' ]
[ to_user: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_user" . }}' ]
[ to_party: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_party" . }}' ]
[ to_tag: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_tag" . }}' ]
</screen>
   </example>
  </sect2>
  <sect2>
   <title>Alertes personnalisées</title>
   <para>
    Vous pouvez définir vos conditions d'alerte personnalisées pour envoyer des notifications à un service externe. Prometheus utilise son propre langage pour définir des alertes personnalisées. Voici un exemple de règle avec une alerte :
   </para>
<screen>
groups:
- name: example
 rules:
  # alert on high deviation from average PG count
  - alert: high pg count deviation
   expr: abs(((ceph_osd_pgs &gt; 0) - on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) / on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) &gt; 0.35
   for: 5m
   labels:
    severity: warning
    type: ses_default
   annotations:
   description: &gt;
    OSD {{ $labels.osd }} deviates by more then 30% from average PG count
</screen>
   <para>
    La clause <literal>for</literal> facultative spécifie le temps que Prometheus attendra entre la première détection d'un nouvel élément de vecteur de sortie d'expression et le comptage d'une alerte comme étant déclenchée. Dans ce cas, Prometheus vérifiera que l'alerte continue d'être active pendant 5 minutes avant de la déclencher. Les éléments en attente sont actifs, mais pas encore déclenchés.
   </para>
   <para>
    La clause <literal>labels</literal> spécifie un ensemble d'étiquettes supplémentaires associées à l'alerte. Les étiquettes contradictoires sont écrasées. Les étiquettes peuvent être modélisées (voir <xref linkend="alertmanager-templates"/> pour plus de détails sur la création de modèles).
   </para>
   <para>
    La clause <literal>annotations</literal> spécifie des étiquettes d'information. Vous pouvez les utiliser pour stocker des informations supplémentaires, par exemple des descriptions d'alerte ou des liens de runbook. Les annotations peuvent être modélisées (voir <xref linkend="alertmanager-templates"/> pour plus de détails sur la création de modèles).
   </para>
   <para>
    Pour ajouter vos alertes personnalisées à SUSE Enterprise Storage 6 :
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Placez vos fichiers YAML avec les alertes personnalisées dans le répertoire <filename>/etc/prometheus/alerts</filename>.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    ou
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Fournissez une liste de chemins vers vos fichiers d'alerte personnalisés dans Pillar sous la clé <option>monitoring:custom_alerts</option>. La phase 2 de DeepSea ou la commande <command>salt <replaceable>SALT_MASTER</replaceable> state.apply ceph.monitoring.prometheus</command> ajoutera vos fichiers d'alertes au bon endroit.
     </para>
     <example>
      <title>ajout d'alertes personnalisées au stockage SUSE Enterprise</title>
      <para>
       Un fichier avec des alertes personnalisées est dans <filename>/root/my_alerts/my_alerts.yml</filename> sur Salt Master. Si vous ajoutez
      </para>
<screen>
monitoring:
 custom_alerts:
   - /root/my_alerts/my_alerts.yml
</screen>
      <para>
       au fichier <filename>/srv/pillar/ceph/cluster/<replaceable>ID_MINION_SALT_MASTER</replaceable>.sls</filename>, DeepSea crée le fichier <filename>/etc/prometheus/alerts/my_alerts.yml</filename> et redémarre Prometheus.
      </para>
     </example>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="alertmanager-templates">
    <title>Modèles</title>
    <para>
     Vous pouvez utiliser des modèles pour les valeurs d'étiquette et d'annotation. La variable <varname>$labels</varname> inclut les paires clé/valeur d'étiquette d'une instance d'alerte, tandis que <varname>$value</varname> contient la valeur évaluée d'une instance d'alerte.
    </para>
    <para>
     L'exemple suivant insère une étiquette et une valeur d'élément de déclenchement :
    </para>
<screen>
{{ $labels.<replaceable>LABELNAME</replaceable> }}
{{ $value }}
</screen>
   </sect3>
   <sect3>
    <title>Inspection des alertes lors de l'exécution</title>
    <para>
     Si vous devez vérifier quelles alertes sont actives, vous avez plusieurs possibilités :
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Accédez à l'onglet <guimenu>Alertes</guimenu> de Prometheus. Il vous montrera les ensembles d'étiquettes exacts pour lesquels des alertes définies sont actives. Prometheus stocke également des séries chronologiques synthétiques pour les alertes en attente et se déclenchant. Elles se présentent comme suit :
      </para>
<screen>
ALERTS{alertname="<replaceable>ALERT_NAME</replaceable>", alertstate="pending|firing", <replaceable>ADDITIONAL_ALERT_LABELS</replaceable>}
</screen>
      <para>
       La valeur de l'échantillon est 1 si l'alerte est active (en attente ou déclenchée). La série est marquée « stale » (obsolète) lorsque l'alerte est inactive.
      </para>
     </listitem>
     <listitem>
      <para>
       Dans l'interface Web de Prometheus à l'adresse URL http://<replaceable>IP_HÔTE_PROMETHEUS</replaceable>:9090/alerts, inspectez les alertes et leur état (INACTIVE, PENDING ou FIRING [INACTIF, EN ATTENTE ou DÉCLENCHÉ]).
      </para>
     </listitem>
     <listitem>
      <para>
       Dans l'interface Web d'Alertmanager à l'adresse URL http://:<replaceable>IP_HÔTE_PROMETHEUS</replaceable>9093/#/alerts, inspectez les alertes et mettez-les en sourdine le cas échéant.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>
  <sect2>
   <title>Récepteur de trappe SNMP</title>
   <para>
    Si vous voulez être informé des alertes Prometheus via des trappes SNMP, alors vous pouvez installer le récepteur de trappe SNMP de Prometheus Alertmanager via DeepSea. Pour ce faire, vous devez l'activer dans Pillar sous la clé <option>monitoring:alertmanager_receiver_snmp:enabled</option>. La configuration du récepteur doit être définie sous la clé <option>monitoring:alertmanager_receiver_snmp:config</option>. La phase 2 de DeepSea ou la commande <command>salt <replaceable>SALT_MASTER</replaceable> state.apply ceph.monitoring.alertmanager</command> installe et configure le récepteur au bon endroit.
   </para>
   <example>
    <title>configuration de trappe SNMP</title>
<screen>
monitoring:
 alertmanager:
   receiver:
      snmp:
        enabled: True
        config:
          host: localhost
          port: 9099
          snmp_host: snmp.foo-bar.com
          snmp_community: private
          metrics: True
</screen>
     <para>
      Reportez-vous au manuel du récepteur à l'adresse <link xlink:href="https://github.com/SUSE/prometheus-webhook-snmp#global-configuration-file"/> pour plus de détails sur les options de configuration.
     </para>
    </example>
  </sect2>
</sect1>

</chapter>
