<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_monitoring_alerting.xml" version="5.0" xml:id="monitoring-alerting">
 <title>Überwachung und Warnmeldungen</title>
 <para>
  In SUSE Enterprise Storage 6 stellt DeepSea keinen Überwachungs- und Warnmeldungs-Stack mehr auf dem Salt Master bereit. Die Benutzer müssen die Prometheus-Rolle für Prometheus und Alertmanager sowie die Grafana-Rolle für Grafana definieren. Wenn mehreren Knoten die Prometheus- oder Grafana-Rolle zugewiesen ist, wird eine hochverfügbare Einrichtung bereitgestellt.
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">Prometheus</emphasis> ist das Überwachungs- und Warnmeldungs-Toolkit.
   </para>
 </listitem>
 <listitem>
  <para>
   <emphasis role="bold">Alertmanager</emphasis> verarbeitet die durch den Prometheus-Server gesendeten Warnmeldungen.
  </para>
 </listitem>
  <listitem>
   <para>
    <emphasis role="bold">Grafana</emphasis> ist die Visualisierungs- und Warnmeldungs-Software.
   </para>
  </listitem>
  <listitem>
   <para>
    <systemitem class="daemon">prometheus-node_exporter</systemitem> ist der auf allen Salt Minions ausgeführte Dienst.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  Die Prometheus-Konfiguration und die <emphasis>scrape</emphasis>-Ziele (Export-Daemons) werden automatisch durch DeepSea eingerichtet. DeepSea stellt außerdem eine Liste standardmäßiger Warnmeldungen bereit, z. B. <literal>health error</literal> (Zustandsfehler), <literal>10% OSDs down</literal> (10 % der OSDs inaktiv) oder <literal>pgs inactive</literal> (PGs inaktiv).
 </para>

 <sect1 xml:id="pillar-variables">
  <title>Pillar-Variablen</title>
  <para>Der Salt Pillar ist ein Schlüssel-Wert-Speicher, der Informationen und Konfigurationswerte an Minions übergibt. Er ist für alle Minions verfügbar, jeweils mit unterschiedlichem Inhalt. Der Salt Pillar ist mit Standardwerten vorbefüllt und kann mit zwei Verfahren angepasst werden:</para>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/global.yml</filename></emphasis>: Ändert Pillar-Variablen für alle Knoten.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/<replaceable>CLUSTER_NAME</replaceable>/minions/<replaceable>HOST</replaceable></filename></emphasis>: Ändert bestimmte Minion-Konfigurationen.
     </para>
    </listitem>
   </itemizedlist>
  <para>
    Die folgenden Pillar-Variablen stehen standardmäßig für alle Knoten zur Verfügung:
  </para>
<screen>
  monitoring:
  alertmanager:
    config: salt://path/to/config
    additional_flags: ''
  grafana:
    ssl_cert: False # self-signed certs are created by default
    ssl_key: False # self-signed certs are created by default
  prometheus:
    # pass additional configration to prometheus
    additional_flags: ''
    alert_relabel_config: []
    rule_files: []
    # per exporter config variables
    scrape_interval:
      ceph: 10
      node_exporter: 10
      prometheus: 10
      grafana: 10
    relabel_config:
      alertmanager: []
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    metric_relabel_config:
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    target_partition:
      ceph: '1/1'
      node_exporter: '1/1'
      prometheus: '1/1'
      grafana: '1/1'
</screen>
</sect1>

<sect1 xml:id="grafana">
  <title>Grafana</title>
  <para>
    Der gesamte Datenverkehr wird durch Grafana verschlüsselt. Sie können entweder eigene SSL-Zertifikate bereitstellen oder ein eigensigniertes Zertifikat erstellen.</para>
  <para>Grafana umfasst die folgenden Variablen:</para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_cert</literal></emphasis>
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_key</literal></emphasis>
      </para>
    </listitem>
  </itemizedlist>
  <para>Weitere Informationen zum Bereitstellen eigener SSL-Zertifikate finden Sie in <xref linkend="cert-sign-CA"/>, weitere Informationen zum Erstellen eines eigenen Zertifikats in <xref linkend="self-sign-certificates"/>.
  </para>
</sect1>

 <sect1 xml:id="prometheus">
   <title>Prometheus</title>
  <para>Prometheus ist die exportprogrammgestützte Konfiguration, die über den Pillar übergeben werden kann. Diese Gruppen werden Exportprogrammen zugeordnet, die Daten bereitstellen. Das Knotenexportprogramm liegt auf allen Knoten vor, Ceph wird durch die Ceph Manager Nodes exportiert, Prometheus und Grafana entsprechend durch die jeweiligen Prometheus- und Grafana-Knoten.</para>
  <para>Prometheus umfasst die folgenden Variablen:</para>
    <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><literal>scrape_interval</literal></emphasis>: Ändert das Scrape-Intervall, also die Häufigkeit des Scrape-Vorgangs für ein Exportprogramm.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>target_partition</literal></emphasis>: Partitioniert die Scrape-Ziele, wenn mehrere Prometheus-Instanzen bereitgestellt wurden, wobei einige Instanzen nur einen Scrape-Vorgang für einen Teil der gesamten Exportprogramminstanzen durchführen sollen.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>relabel_config</literal></emphasis>: Schreibt die Kennzeichnungssätze eines Ziels vor Beginn des Scrape-Vorgangs dynamisch neu. Für eine Scrape-Konfiguration können mehrere Neukennzeichnungsschritte konfiguriert werden.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>metrics_relabel_config</literal></emphasis>: Wird als letzter Schritt vor der Aufnahme auf Beispiele angewendet.
     </para>
    </listitem>
   </itemizedlist>
 </sect1>

 <sect1 xml:id="alerting-alertmanager">
  <title>Alertmanager</title>
  <para>
   Alertmanager verarbeitet die durch den Prometheus-Server gesendeten Warnmeldungen. Hiermit werden die Warnmeldungen dedupliziert, gruppiert und an den richtigen Empfänger geleitet. Außerdem werden Warnmeldungen stummgeschaltet. Alertmanager wird über die Befehlszeilenflaggen und eine Konfigurationsdatei konfiguriert, in der die Sperrregeln, das Benachrichtigungs-Routing und die Benachrichtigungsempfänger definiert sind.
  </para>
  <sect2>
   <title>Konfigurationsdatei</title>
   <para>
    Die Alertmanager-Konfiguration ist für jede Bereitstellung anders. DeepSea bietet daher keine entsprechenden Standardeinstellungen. Sie müssen eine eigene <filename>alertmanager.yml</filename>-Konfigurationsdatei bereitstellen. Die Variable
    <package>Alertmanager</package> installiert standardmäßig die Konfigurationsdatei <filename>/etc/prometheus/alertmanager.yml</filename>, die als Beispielkonfiguration dienen kann. Wenn die Alertmanager-Konfiguration stattdessen von DeepSea verwaltet werden soll, ergänzen Sie den Pillar (z. B. die Datei<filename>/srv/pillar/ceph/stack/ceph/minions/<replaceable>YOUR_SALT_MASTER_MINION_ID</replaceable>.sls</filename>) mit dem folgenden Schlüssel:
   </para>
   <para>
    Ein Beispiel für die gesamte Alertmanager-Konfigurationsdatei finden Sie in <xref linkend="app-alerting-default"/>.
   </para>
<screen>
monitoring:
 alertmanager_config:
   /path/to/your/alertmanager/config.yml
</screen>
   <para>
    Die Alertmanager-Konfigurationsdatei ist im YAML-Format gespeichert. Hierbei gilt das nachfolgende Schema. Parameter in Klammern sind optional. Bei nicht aufgeführten Parametern wird der Standardwert herangezogen. Das Schema umfasst die folgenden generischen Platzhalter:
   </para>
   <variablelist>
    <varlistentry>
     <term><replaceable>DURATION</replaceable></term>
     <listitem>
      <para>
       Dauer gemäß dem regulären Ausdruck <literal>[0-9]+(ms|[smhdwy])</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELNAME</replaceable></term>
     <listitem>
      <para>
       Zeichenkette gemäß dem regulären Ausdruck <literal>[a-zA-Z_][a-zA-Z0-9_]*</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELVALUE</replaceable></term>
     <listitem>
      <para>
       Zeichenkette mit Unicode-Zeichen.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>FILEPATH</replaceable></term>
     <listitem>
      <para>
       Gültiger Pfad im aktuellen Arbeitsverzeichnis.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>BOOLEAN</replaceable></term>
     <listitem>
      <para>
       Boolescher Wert mit den Optionen „true“ oder #false“.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>STRING</replaceable></term>
     <listitem>
      <para>
       Normale Zeichenkette.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>SECRET</replaceable></term>
     <listitem>
      <para>
       Normale Zeichenkette, die als Geheimnis fungiert, z. B. ein Passwort.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_STRING</replaceable></term>
     <listitem>
      <para>
       Zeichenkette, die vor der Verwendung per Schablone erweitert wird.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_SECRET</replaceable></term>
     <listitem>
      <para>
       Geheime Zeichenkette, die vor der Verwendung per Schablone erweitert wird.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <example>
    <title>Globale Konfiguration</title>
    <para>
     Die Parameter in der Konfiguration <literal>global:</literal> gelten auch in allen anderen Konfigurationskontexten. Zudem fungieren sie als Standardwerte für andere Konfigurationsabschnitte.
    </para>
<screen>
global:
# the time after which an alert is declared resolved if it has not been updated
[ resolve_timeout: <replaceable>DURATION</replaceable> | default = 5m ]

# The default SMTP From header field.
[ smtp_from: <replaceable>TMPL_STRING</replaceable> ]
# The default SMTP smarthost used for sending emails, including port number.
# Port number usually is 25, or 587 for SMTP over TLS
# (sometimes referred to as STARTTLS).
# Example: smtp.example.org:587
[ smtp_smarthost: <replaceable>STRING</replaceable> ]
# The default host name to identify to the SMTP server.
[ smtp_hello: <replaceable>STRING</replaceable> | default = "localhost" ]
[ smtp_auth_username: <replaceable>STRING</replaceable> ]
# SMTP Auth using LOGIN and PLAIN.
[ smtp_auth_password: <replaceable>SECRET</replaceable> ]
# SMTP Auth using PLAIN.
[ smtp_auth_identity: <replaceable>STRING</replaceable> ]
# SMTP Auth using CRAM-MD5.
[ smtp_auth_secret: <replaceable>SECRET</replaceable> ]
# The default SMTP TLS requirement.
[ smtp_require_tls: <replaceable>BOOL</replaceable> | default = true ]

# The API URL to use for Slack notifications.
[ slack_api_url: <replaceable>STRING</replaceable> ]
[ victorops_api_key: <replaceable>STRING</replaceable> ]
[ victorops_api_url: <replaceable>STRING</replaceable> | default = "https://victorops.example.com/integrations/alert/" ]
[ pagerduty_url: <replaceable>STRING</replaceable> | default = "https://pagerduty.example.com/v2/enqueue" ]
[ opsgenie_api_key: <replaceable>STRING</replaceable> ]
[ opsgenie_api_url: <replaceable>STRING</replaceable> | default = "https://opsgenie.example.com/" ]
[ hipchat_api_url: <replaceable>STRING</replaceable> | default = "https://hipchat.example.com/" ]
[ hipchat_auth_token: <replaceable>SECRET</replaceable> ]
[ wechat_api_url: <replaceable>STRING</replaceable> | default = "https://wechat.example.com/cgi-bin/" ]
[ wechat_api_secret: <replaceable>SECRET</replaceable> ]
[ wechat_api_corp_id: <replaceable>STRING</replaceable> ]

# The default HTTP client configuration
[ http_config: <replaceable>HTTP_CONFIG</replaceable> ]

# Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - <replaceable>FILEPATH</replaceable> ... ]

# The root node of the routing tree.
route: <replaceable>ROUTE</replaceable>

# A list of notification receivers.
receivers:
- <replaceable>RECEIVER</replaceable> ...

# A list of inhibition rules.
inhibit_rules:
[ - <replaceable>INHIBIT_RULE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>ROUTE</replaceable></title>
    <para>
     Ein <replaceable>ROUTE</replaceable>-Block definiert einen Knoten in einem Routing-Baum. Nicht angegebene Parameter werden aus dem übergeordneten Knoten übernommen. Jede Warnmeldung gelangt über die konfigurierte allgemeine Route, die mit allen Warnmeldungen übereinstimmen muss, in den Routing-Baum. Anschließend durchläuft sie die untergeordneten Knoten. Wenn die Option <option>continue</option> auf „false“ eingestellt ist, endet der Durchlauf nach dem ersten untergeordneten Knoten mit Übereinstimmung. Wird die Option auf einem Knoten mit Übereinstimmung auf „true“ eingestellt, wird die Warnmeldung mit nachfolgenden Knoten auf derselben Ebene abgeglichen. Stimmt die Warnmeldung mit keinem untergeordneten Knoten eines Knotens überein, wird sie gemäß den Konfigurationsparametern des aktuellen Knotens verarbeitet.
    </para>
<screen>
[ receiver: <replaceable>STRING</replaceable> ]
[ group_by: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]

# If an alert should continue matching subsequent sibling nodes.
[ continue: <replaceable>BOOLEAN</replaceable> | default = false ]

# A set of equality matchers an alert has to fulfill to match a node.
match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]

# A set of regex-matchers an alert has to fulfill to match a node.
match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Time to wait before sending a notification for a group of alerts.
[ group_wait: <replaceable>DURATION</replaceable> | default = 30s ]

# Time to wait before sending a notification about new alerts
# added to a group of alerts for which an initial notification has
# already been sent.
[ group_interval: <replaceable>DURATION</replaceable> | default = 5m ]

# Time to wait before re-sending a notification
[ repeat_interval: <replaceable>DURATION</replaceable> | default = 4h ]

# Possible child routes.
routes:
 [ - <replaceable>ROUTE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>INHIBIT_RULE</replaceable></title>
    <para>
     Eine Sperrregel schaltet eine Zielwarnmeldung, die mit einer Abgleichreihe übereinstimmt, stumm, wenn eine Quellwarnmeldung vorliegt, die mit einer anderen Abgleichreihe übereinstimmt. Beide Warnmeldungen müssen dieselben Kennzeichnungswerte für die Kennzeichnungsnamen in der Liste <option>equal</option> aufweisen.
    </para>
    <para>
     Warnmeldungen können mit sich selbst übereinstimmen und sich folglich selbst sperren. Schreiben Sie keine Sperrregeln, in der eine Warnmeldung sowohl mit der Quelle als auch mit dem Ziel übereinstimmt.
    </para>
<screen>
# Matchers that need to be fulfilled for the alerts to be muted.
target_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
target_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Matchers for which at least one alert needs to exist so that the
# inhibition occurs.
source_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
source_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Labels with an equal value in the source and target
# alert for the inhibition to take effect.
[ equal: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]
</screen>
   </example>
   <example>
    <title><replaceable>HTTP_CONFIG</replaceable></title>
    <para>
     Mit <replaceable>HTTP_CONFIG</replaceable> wird der HTTP-Client konfiguriert, über den der Empfänger mit den API-Diensten kommuniziert.
    </para>
    <para>
     Die Optionen <option>basic_auth</option>, <option>bearer_token</option> und <option>bearer_token_file</option> schließen sich gegenseitig aus.
    </para>
<screen>
# Sets the 'Authorization' header with the user name and password.
basic_auth:
[ username: <replaceable>STRING</replaceable> ]
[ password: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token.
[ bearer_token: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token read from a file.
[ bearer_token_file: <replaceable>FILEPATH</replaceable> ]

# TLS settings.
tls_config:
# CA certificate to validate the server certificate with.
[ ca_file: <replaceable>FILEPATH</replaceable> ]
# Certificate and key files for client cert authentication to the server.
[ cert_file: <replaceable>FILEPATH</replaceable> ]
[ key_file: <replaceable>FILEPATH</replaceable> ]
# ServerName extension to indicate the name of the server.
# http://tools.ietf.org/html/rfc4366#section-3.1
[ server_name: <replaceable>STRING</replaceable> ]
# Disable validation of the server certificate.
[ insecure_skip_verify: <replaceable>BOOLEAN</replaceable> | default = false]

# Optional proxy URL.
[ proxy_url: <replaceable>STRING</replaceable> ]
</screen>
   </example>
   <example>
    <title><replaceable>RECEIVER</replaceable></title>
    <para>
     „Receiver“ ist eine benannte Konfiguration für eine oder mehrere Benachrichtigungsintegrationen.
    </para>
    <para>
     Statt neue Empfänger hinzuzufügen, wird empfohlen, benutzerdefinierte Benachrichtigungsintegrationen über den Webhook-Empfänger einzurichten (siehe <xref linkend="alert-webhook"/>).
    </para>
<screen>
# The unique name of the receiver.
name: <replaceable>STRING</replaceable>

# Configurations for several notification integrations.
email_configs:
[ - <replaceable>EMAIL_CONFIG</replaceable>, ... ]
hipchat_configs:
[ - <replaceable>HIPCHAT_CONFIG</replaceable>, ... ]
pagerduty_configs:
[ - <replaceable>PAGERDUTY_CONFIG</replaceable>, ... ]
pushover_configs:
[ - <replaceable>PUSHOVER_CONFIG</replaceable>, ... ]
slack_configs:
[ - <replaceable>SLACK_CONFIG</replaceable>, ... ]
opsgenie_configs:
[ - <replaceable>OPSGENIE_CONFIG</replaceable>, ... ]
webhook_configs:
[ - <replaceable>WEBHOOK_CONFIG</replaceable>, ... ]
victorops_configs:
[ - <replaceable>VICTOROPS_CONFIG</replaceable>, ... ]
wechat_configs:
[ - <replaceable>WECHAT_CONFIG</replaceable>, ... ]
</screen>
   </example>
   <example>
    <title><replaceable>EMAIL_CONFIG</replaceable></title>
<screen>
# Whether to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The email address to send notifications to.
to: <replaceable>TMPL_STRING</replaceable>

# The sender address.
[ from: <replaceable>TMPL_STRING</replaceable> | default = global.smtp_from ]

# The SMTP host through which emails are sent.
[ smarthost: <replaceable>STRING</replaceable> | default = global.smtp_smarthost ]

# The host name to identify to the SMTP server.
[ hello: <replaceable>STRING</replaceable> | default = global.smtp_hello ]

# SMTP authentication details.
[ auth_username: <replaceable>STRING</replaceable> | default = global.smtp_auth_username ]
[ auth_password: <replaceable>SECRET</replaceable> | default = global.smtp_auth_password ]
[ auth_secret: <replaceable>SECRET</replaceable> | default = global.smtp_auth_secret ]
[ auth_identity: <replaceable>STRING</replaceable> | default = global.smtp_auth_identity ]

# The SMTP TLS requirement.
[ require_tls: <replaceable>BOOL</replaceable> | default = global.smtp_require_tls ]

# The HTML body of the email notification.
[ html: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "email.default.html" . }}' ]
# The text body of the email notification.
[ text: <replaceable>TMPL_STRING</replaceable> ]

# Further headers email header key/value pairs. Overrides any headers
# previously set by the notification implementation.
[ headers: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]
</screen>
   </example>
   <example>
    <title><replaceable>HIPCHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The HipChat Room ID.
room_id: <replaceable>TMPL_STRING</replaceable>
# The authentication token.
[ auth_token: <replaceable>SECRET</replaceable> | default = global.hipchat_auth_token ]
# The URL to send API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.hipchat_api_url ]

# A label to be shown in addition to the sender's name.
[ from:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.from" . }}' ]
# The message body.
[ message:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.message" . }}' ]
# Whether this message will trigger a user notification.
[ notify:  <replaceable>BOOLEAN</replaceable> | default = false ]
# Determines how the message is treated by the alertmanager and rendered inside HipChat. Valid values are 'text' and 'html'.
[ message_format:  <replaceable>STRING</replaceable> | default = 'text' ]
# Background color for message.
[ color:  <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}red{{ else }}green{{ end }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PAGERDUTY_CONFIG</replaceable></title>
    <para>
     Die Optionen <option>routing_key</option> und <option>service_key</option> schließen sich gegenseitig aus.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The PagerDuty integration key (when using 'Events API v2').
routing_key: <replaceable>TMPL_SECRET</replaceable>
# The PagerDuty integration key (when using 'Prometheus').
service_key: <replaceable>TMPL_SECRET</replaceable>

# The URL to send API requests to.
[ url: <replaceable>STRING</replaceable> | default = global.pagerduty_url ]

# The client identification of the Alertmanager.
[ client:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.client" . }}' ]
# A backlink to the notification sender.
[ client_url:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.clientURL" . }}' ]

# The incident description.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.description" .}}' ]

# Severity of the incident.
[ severity: <replaceable>TMPL_STRING</replaceable> | default = 'error' ]

# A set of arbitrary key/value pairs that provide further details.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } | default = {
 firing:       '{{ template "pagerduty.default.instances" .Alerts.Firing }}'
 resolved:     '{{ template "pagerduty.default.instances" .Alerts.Resolved }}'
 num_firing:   '{{ .Alerts.Firing | len }}'
 num_resolved: '{{ .Alerts.Resolved | len }}'
} ]

# The HTTP client's configuration.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PUSHOVER_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The recipient user key.
user_key: <replaceable>SECRET</replaceable>

# Registered application’s API token.
token: <replaceable>SECRET</replaceable>

# Notification title.
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.title" . }}' ]

# Notification message.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.message" . }}' ]

# A supplementary URL displayed together with the message.
[ url: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.url" . }}' ]

# Priority.
[ priority: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}2{{ else }}0{{ end }}' ]

# How often the Pushover servers will send the same notification (at least 30 seconds).
[ retry: <replaceable>DURATION</replaceable> | default = 1m ]

# How long your notification will continue to be retried (unless the user
# acknowledges the notification).
[ expire: <replaceable>DURATION</replaceable> | default = 1h ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The Slack webhook URL.
[ api_url: <replaceable>SECRET</replaceable> | default = global.slack_api_url ]

# The channel or user to send notifications to.
channel: <replaceable>TMPL_STRING</replaceable>

# API request data as defined by the Slack webhook API.
[ icon_emoji: <replaceable>TMPL_STRING</replaceable> ]
[ icon_url: <replaceable>TMPL_STRING</replaceable> ]
[ link_names: <replaceable>BOOLEAN</replaceable> | default = false ]
[ username: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.username" . }}' ]
# The following parameters define the attachment.
actions:
[ <replaceable>ACTION_CONFIG</replaceable> ... ]
[ color: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}danger{{ else }}good{{ end }}' ]
[ fallback: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.fallback" . }}' ]
fields:
[ <replaceable>FIELD_CONFIG</replaceable> ... ]
[ footer: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.footer" . }}' ]
[ pretext: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.pretext" . }}' ]
[ short_fields: <replaceable>BOOLEAN</replaceable> | default = false ]
[ text: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.text" . }}' ]
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.title" . }}' ]
[ title_link: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.titlelink" . }}' ]
[ image_url: <replaceable>TMPL_STRING</replaceable> ]
[ thumb_url: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>ACTION_CONFIG</replaceable> für <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Provide a button to tell Slack you want to render a button.
type: <replaceable>TMPL_STRING</replaceable>
# Label for the button.
text: <replaceable>TMPL_STRING</replaceable>
# http or https URL to deliver users to. If you specify invalid URLs, the message will be posted with no button.
url: <replaceable>TMPL_STRING</replaceable>
#  If set to 'primary', the button will be green, indicating the best forward action to take
#  'danger' turns the button red, indicating a destructive action.
[ style: <replaceable>TMPL_STRING</replaceable> [ default = '' ]
</screen>
   </example>
   <example>
    <title><replaceable>FIELD_CONFIG</replaceable> für <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# A bold heading without markup above the <option>value</option> text.
title: <replaceable>TMPL_STRING</replaceable>
# The text of the field. It can span across several lines.
value: <replaceable>TMPL_STRING</replaceable>
# A flag indicating if <option>value</option> is short enough to be displayed together with other values.
[ short: <replaceable>BOOLEAN</replaceable> | default = slack_config.short_fields ]
</screen>
   </example>
   <example>
    <title><replaceable>OPSGENIE_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key to use with the OpsGenie API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.opsgenie_api_key ]

# The host to send OpsGenie API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.opsgenie_api_url ]

# Alert text (maximum is 130 characters).
[ message: <replaceable>TMPL_STRING</replaceable> ]

# A description of the incident.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.description" . }}' ]

# A backlink to the sender.
[ source: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.source" . }}' ]

# A set of arbitrary key/value pairs that provide further detail.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]

# Comma separated list of team responsible for notifications.
[ teams: <replaceable>TMPL_STRING</replaceable> ]

# Comma separated list of tags attached to the notifications.
[ tags: <replaceable>TMPL_STRING</replaceable> ]

# Additional alert note.
[ note: <replaceable>TMPL_STRING</replaceable> ]

# Priority level of alert, one of P1, P2, P3, P4, and P5.
[ priority: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>VICTOROPS_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key for talking to the VictorOps API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.victorops_api_key ]

# The VictorOps API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.victorops_api_url ]

# A key used to map the alert to a team.
routing_key: <replaceable>TMPL_STRING</replaceable>

# Describes the behavior of the alert (one of 'CRITICAL', 'WARNING', 'INFO').
[ message_type: <replaceable>TMPL_STRING</replaceable> | default = 'CRITICAL' ]

# Summary of the alerted problem.
[ entity_display_name: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.entity_display_name" . }}' ]

# Long explanation of the alerted problem.
[ state_message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.state_message" . }}' ]

# The monitoring tool the state message is from.
[ monitoring_tool: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.monitoring_tool" . }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example xml:id="alert-webhook">
    <title><replaceable>WEBHOOK_CONFIG</replaceable></title>
    <para>
     Mit dem Webhook-Empfänger können Sie einen generischen Empfänger konfigurieren.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The endpoint for sending HTTP POST requests.
url: <replaceable>STRING</replaceable>

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
    <para>
     Alertmanager sendet HTTP-POST-Anfragen im folgenden JSON-Format:
    </para>
<screen>
{
 "version": "4",
 "groupKey": <replaceable>STRING</replaceable>, // identifycation of the group of alerts (to deduplicate)
 "status": "&lt;resolved|firing&gt;",
 "receiver": <replaceable>STRING</replaceable>,
 "groupLabels": <replaceable>OBJECT</replaceable>,
 "commonLabels": <replaceable>OBJECT</replaceable>,
 "commonAnnotations": <replaceable>OBJECT</replaceable>,
 "externalURL": <replaceable>STRING</replaceable>, // backlink to Alertmanager.
 "alerts": [
   {
     "status": "&lt;resolved|firing&gt;",
     "labels": <replaceable>OBJECT</replaceable>,
     "annotations": <replaceable>OBJECT</replaceable>,
     "startsAt": "&lt;rfc3339&gt;",
     "endsAt": "&lt;rfc3339&gt;",
     "generatorURL": <replaceable>STRING</replaceable> // identifies the entity that caused the alert
   },
   ...
 ]
}
</screen>
    <para>
     Der Webhook-Empfänger ermöglicht die Integration in die folgenden Benachrichtigungsmechanismen:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       DingTalk (https://github.com/timonwong/prometheus-webhook-dingtalk)
      </para>
     </listitem>
     <listitem>
      <para>
       IRC-Bot (https://github.com/multimfi/bot)
      </para>
     </listitem>
     <listitem>
      <para>
       JIRAlert (https://github.com/free/jiralert)
      </para>
     </listitem>
     <listitem>
      <para>
       Phabricator/Maniphest (https://github.com/knyar/phalerts)
      </para>
     </listitem>
     <listitem>
      <para>
       prom2teams: leitet Benachrichtigungen an Microsoft-Teams weiter (https://github.com/idealista/prom2teams)
      </para>
     </listitem>
     <listitem>
      <para>
       SMS: unterstützt mehrere Anbieter (https://github.com/messagebird/sachet)
      </para>
     </listitem>
     <listitem>
      <para>
       Telegram-Bot (https://github.com/inCaller/prometheus_bot)
      </para>
     </listitem>
     <listitem>
      <para>
       SNMP-Trap (https://github.com/SUSE/prometheus-webhook-snmp)
      </para>
     </listitem>
    </itemizedlist>
   </example>
   <example>
    <title><replaceable>WECHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The API key to use for the WeChat API.
[ api_secret: <replaceable>SECRET</replaceable> | default = global.wechat_api_secret ]

# The WeChat API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.wechat_api_url ]

# The corp id used to authenticate.
[ corp_id: <replaceable>STRING</replaceable> | default = global.wechat_api_corp_id ]

# API request data as defined by the WeChat API.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "wechat.default.message" . }}' ]
[ agent_id: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.agent_id" . }}' ]
[ to_user: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_user" . }}' ]
[ to_party: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_party" . }}' ]
[ to_tag: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_tag" . }}' ]
</screen>
   </example>
  </sect2>
  <sect2>
   <title>Benutzerdefinierte Warnmeldungen</title>
   <para>
    Sie können benutzerdefinierte Warnmeldungen definieren und damit Benachrichtigungen an einen externen Dienst senden. In Prometheus werden benutzerdefinierte Warnmeldungen mit der softwareeigenen Ausdruckssprache definiert. Beispiel für eine Regel mit einer Warnmeldung:
   </para>
<screen>
groups:
- name: example
 rules:
  # alert on high deviation from average PG count
  - alert: high pg count deviation
   expr: abs(((ceph_osd_pgs &gt; 0) - on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) / on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) &gt; 0.35
   for: 5m
   labels:
    severity: warning
    type: ses_default
   annotations:
   description: &gt;
    OSD {{ $labels.osd }} deviates by more then 30% from average PG count
</screen>
   <para>
    Die optionale <literal>for</literal>-Anweisung gibt an, wie lang Prometheus zwischen dem Auftreten eines neuen Ausdrucksausgabe-Vektorelements und dem Auslösen einer Warnmeldung abwartet. In diesem Fall prüft Prometheus, ob die Warnmeldung 5 Minuten lang aktiv bleibt, bevor die Warnmeldung ausgelöst wird. Elemente mit dem Status „ausstehend“ sind aktiv, werden jedoch noch nicht ausgelöst.
   </para>
   <para>
    Mit der <literal>labels</literal>-Anweisung wird eine Reihe zusätzlicher Kennzeichnungen angegeben, die mit der Warnmeldung verbunden sind. Widersprüchliche Kennzeichnungen werden überschrieben. Für die Kennzeichnungen können Schablonen angelegt werden (weitere Informationen zu Schablonen siehe <xref linkend="alertmanager-templates"/>).
   </para>
   <para>
    Mit der <literal>annotations</literal>-Anweisung werden Informationskennzeichnungen angegeben. Hiermit können Sie zusätzliche Informationen speichern, z. B. Beschreibungen der Warnmeldungen oder Runbook-Links. Für die Anmerkungen können Schablonen angelegt werden (weitere Informationen zu Schablonen siehe <xref linkend="alertmanager-templates"/>).
   </para>
   <para>
    So fügen Sie die benutzerdefinierten Warnmeldungen in SUSE Enterprise Storage 6 ein:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Speichern Sie die YAML-Dateien mit den benutzerdefinierten Warnmeldungen im Verzeichnis <filename>/etc/prometheus/alerts</filename>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    oder
   </para>
   <itemizedlist>
    <listitem>
     <para>
      geben Sie im Pillar unter dem Schlüssel <option>monitoring:custom_alerts</option> eine Liste der Pfade zu den benutzerdefinierten Warnmeldungsdateien an. Mit der DeepSea-Phase 2 oder dem Kommando <command>salt <replaceable>SALT_MASTER</replaceable> state.apply ceph.monitoring.prometheus</command> werden die Warnmeldungsdateien an der richtigen Stelle eingefügt.
     </para>
     <example>
      <title>Einfügen benutzerdefinierter Warnmeldungen in SUSE Enterprise Storage</title>
      <para>
       Eine Datei mit benutzerdefinierten Warnmeldungen befindet sich in <filename>/root/my_alerts/my_alerts.yml</filename> auf dem Salt Master. Wenn Sie
      </para>
<screen>
monitoring:
 custom_alerts:
   - /root/my_alerts/my_alerts.yml
</screen>
      <para>
       in die Datei <filename>/srv/pillar/ceph/cluster/<replaceable>YOUR_SALT_MASTER_MINION_ID</replaceable>.sls</filename> einfügen, erstellt DeepSea die Datei <filename>/etc/prometheus/alerts/my_alerts.yml</filename> und startet Prometheus neu.
      </para>
     </example>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="alertmanager-templates">
    <title>Vorlagen</title>
    <para>
     Sie können Schablonen für Kennzeichnungs- und Anmerkungswerte heranziehen. Die Variable
     <varname>$Etiketten</varname> umfasst die Schlüssel-Wert-Paare für die Kennzeichnungen einer Warnmeldungsinstanz, <varname>$value</varname> enthält dagegen den ausgewerteten Wert einer Warnmeldungsinstanz.
    </para>
    <para>
     Mit dem folgenden Beispiel werden eine Kennzeichnung und ein Wert für ein Auslösungselement eingefügt:
    </para>
<screen>
{{ $labels.<replaceable>LABELNAME</replaceable> }}
{{ $value }}
</screen>
   </sect3>
   <sect3>
    <title>Prüfen von Warnmeldungen zur Laufzeit</title>
    <para>
     Soll festgestellt werden, welche Warnmeldungen aktiv sind, stehen mehrere Optionen zur Auswahl:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Navigieren Sie zur Registerkarte <guimenu>Alerts</guimenu> in Prometheus. Hier werden die genauen Kennzeichnungssätze angezeigt, für die die definierten Warnmeldungen aktiviert sind. Prometheus speichert außerdem eine synthetische Zeitfolge für ausstehende und ausgelöste Warnmeldungen. Sie weisen folgende Form auf:
      </para>
<screen>
ALERTS{alertname="<replaceable>ALERT_NAME</replaceable>", alertstate="pending|firing", <replaceable>ADDITIONAL_ALERT_LABELS</replaceable>}
</screen>
      <para>
       Der Beispielwert lautet 1, wenn die Warnmeldung aktiv ist (ausstehend oder ausgelöst). Ist die Warnmeldung inaktiv, wird die Reihe als „stale“ gekennzeichnet.
      </para>
     </listitem>
     <listitem>
      <para>
       In der Prometheus-Weboberfläche unter der URL-Adresse http://<replaceable>PROMETHEUS_HOST_IP</replaceable>:9090/alerts können Sie die Warnmeldungen und ihren Status (INACTIVE, PENDING oder FIRING) prüfen.
      </para>
     </listitem>
     <listitem>
      <para>
       In er Alertmanager-Weboberfläche unter der URL-Adresse http://:<replaceable>PROMETHEUS_HOST_IP</replaceable>9093/#/alerts können Sie Warnmeldungen prüfen und bei Bedarf stummschalten.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>
  <sect2>
   <title>SNMP-Trap-Empfänger</title>
   <para>
    Wenn Sie mithilfe von SNMP-Traps über Prometheus-Warnmeldungen benachrichtigt werden möchten, können Sie den Prometheus-Alertmanager-SNMP-Trap-Empfänger über DeepSea installieren. Aktivieren Sie ihn hierzu im Pillar unter dem Schlüssel <option>monitoring:alertmanager_receiver_snmp:enabled</option>. Die Konfiguration des Empfängers muss unter dem Schlüssel <option>monitoring:alertmanager_receiver_snmp:config</option> festgelegt werden. Mit der DeepSea-Phase 2 oder dem Kommando <command>salt <replaceable>SALT_MASTER</replaceable> state.apply ceph.monitoring.alertmanager</command> wird der Empfänger am richtigen Speicherort installiert und konfiguriert.
   </para>
   <example>
    <title>SNMP-Trap-Konfiguration</title>
<screen>
monitoring:
 alertmanager:
   receiver:
      snmp:
        enabled: True
        config:
          host: localhost
          port: 9099
          snmp_host: snmp.foo-bar.com
          snmp_community: private
          metrics: True
</screen>
     <para>
      Im Empfängerhandbuch unter <link xlink:href="https://github.com/SUSE/prometheus-webhook-snmp#global-configuration-file"/> finden Sie weitere Informationen zu den Konfigurationsoptionen.
     </para>
    </example>
  </sect2>
</sect1>

</chapter>
