<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_monitoring_alerting.xml" version="5.0" xml:id="monitoring-alerting">
 <title>Supervisión y alertas</title>
 <para>
  En SUSE Enterprise Storage 6, DeepSea ya no distribuye una pila de supervisión y alertas en el master de Salt. Los usuarios tienen que definir la función de Prometheus para Prometheus y Alertmanager, y la función de Grafana para Grafana. Cuando se asignan varios nodos con la función de Prometheus o Grafana, se distribuye una configuración de alta disponibilidad.
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">Prometheus</emphasis> es el kit de herramientas de supervisión y alertas.
   </para>
 </listitem>
 <listitem>
  <para>
   <emphasis role="bold">Alertmanager</emphasis> gestiona las alertas enviadas por el servidor de Prometheus.
  </para>
 </listitem>
  <listitem>
   <para>
    <emphasis role="bold">Grafana</emphasis> es el software de visualización y alertas.
   </para>
  </listitem>
  <listitem>
   <para>
    <systemitem class="daemon">prometheus-node_exporter</systemitem> es el servicio que se ejecuta en todos los minions de Salt.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  DeepSea configura automáticamente los valores de Prometheus y los destinos de <emphasis>scrape</emphasis> (daemons de exportación). DeepSea también distribuye una lista de alertas por defecto, por ejemplo, <literal>error de estado</literal>, <literal>10% de OSD inactivos</literal> o <literal>pgs inactivos</literal>.
 </para>

 <sect1 xml:id="pillar-variables">
  <title>Variables de pilar</title>
  <para>El pilar de Salt es un almacén clave-valor que proporciona información y valores de configuración a los minions. Está disponible para todos los minions, cada uno con contenido diferente. El pilar de Salt se rellena previamente con valores por defecto y se puede personalizar de dos maneras:</para>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/global.yml</filename></emphasis>: para cambiar las variables del pilar en todos los nodos.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/<replaceable/>NOMBRE_CLUSTER<replaceable>/minions/HOST</replaceable></filename></emphasis>: para cambiar configuraciones específicas de minions.
     </para>
    </listitem>
   </itemizedlist>
  <para>
    Las siguientes variables de pilar están disponibles por defecto para todos los nodos:
  </para>
<screen>
  monitoring:
  alertmanager:
    config: salt://path/to/config
    additional_flags: ''
  grafana:
    ssl_cert: False # self-signed certs are created by default
    ssl_key: False # self-signed certs are created by default
  prometheus:
    # pass additional configration to prometheus
    additional_flags: ''
    alert_relabel_config: []
    rule_files: []
    # per exporter config variables
    scrape_interval:
      ceph: 10
      node_exporter: 10
      prometheus: 10
      grafana: 10
    relabel_config:
      alertmanager: []
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    metric_relabel_config:
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    target_partition:
      ceph: '1/1'
      node_exporter: '1/1'
      prometheus: '1/1'
      grafana: '1/1'
</screen>
</sect1>

<sect1 xml:id="grafana">
  <title>Grafana</title>
  <para>
    Todo el tráfico se cifra a través de Grafana. Es posible proporcionar certificados SSL propios o crear uno autofirmado.</para>
  <para>Grafana utiliza las variables siguientes:</para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_cert</literal></emphasis>
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_key</literal></emphasis>
      </para>
    </listitem>
  </itemizedlist>
  <para>Para obtener más información sobre cómo proporcionar certificados SSL propios, consulte la <xref linkend="cert-sign-CA"/>. Para saber cómo crearlos, consulte la <xref linkend="self-sign-certificates"/>.
  </para>
</sect1>

 <sect1 xml:id="prometheus">
   <title>Prometheus</title>
  <para>La configuración basada en el exportador que se puede pasar a través del pilar. Estos grupos se asignan a los exportadores que proporcionan datos. El exportador de nodos está presente en todos los nodos, los nodos de Ceph Manager exportan Ceph; los nodos de Prometheus y Grafana exportan Prometheus y Grafana, respectivamente.</para>
  <para>Prometheus utiliza las siguientes variables:</para>
    <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><literal>scrape_interval:</literal></emphasis> cambia el intervalo de scrape ("sondeo", en terminología de Prometheus), es decir la frecuencia con la que el exportador realiza el sondeo.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>target_partition:</literal></emphasis> los destinos de scrape de la partición si se distribuyen varias instancias de Prometheus y algunas de ellas solo realizan el scrape de una parte de todas las instancias del exportador.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>relabel_config:</literal></emphasis> reescribe dinámicamente el conjunto de etiquetas de un destino antes de que se realice el scrape. Se pueden configurar varios pasos de reetiquetado por cada configuración de scrape.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>metrics_relabel_config:</literal></emphasis> se aplica a las muestras como último paso antes de la ingesta.
     </para>
    </listitem>
   </itemizedlist>
 </sect1>

 <sect1 xml:id="alerting-alertmanager">
  <title>Alertmanager</title>
  <para>
   Alertmanager gestiona las alertas enviadas por el servidor de Prometheus. Se encarga de desduplicarlos, agruparlos y enrutarlos al receptor correcto. También se encarga de silenciar las alertas. Alertmanager se configura mediante los indicadores de la línea de comandos y un archivo de configuración que define las reglas de inhibición, el enrutamiento de notificaciones y los receptores de las notificaciones.
  </para>
  <sect2>
   <title>Archivo de configuración</title>
   <para>
    La configuración de Alertmanager es diferente en cada distribución. Por lo tanto, DeepSea no incluye ningún valor por defecto. Debe proporcionar su propio archivo de configuración <filename>alertmanager.yml</filename>. El paquete
    <package>alertmanager</package> instala por defecto un archivo de configuración <filename>/etc/prometheus/alertmanager.yml</filename> que puede servir como configuración de ejemplo. Si prefiere que DeepSea gestione la configuración de Alertmanager, añada la clave siguiente al pilar, por ejemplo, al archivo <filename>/srv/pillar/ceph/stack/ceph/minions/<replaceable>ID_DE_MINION_DE_SU_MASTER_DE_SALT</replaceable>.sls</filename>:
   </para>
   <para>
    Para ver un ejemplo completo de un archivo de configuración de Alertmanager, consulte el <xref linkend="app-alerting-default"/>.
   </para>
<screen>
monitoring:
 alertmanager_config:
   /path/to/your/alertmanager/config.yml
</screen>
   <para>
    El archivo de configuración de Alertmanager está escrito en formato YAML. Sigue el esquema descrito a continuación. Los parámetros entre corchetes son opcionales. Para los parámetros que no aparecen en la lista, se utiliza el valor por defecto. En el esquema se utilizan los siguientes marcadores de posición genéricos:
   </para>
   <variablelist>
    <varlistentry>
     <term><replaceable>DURATION</replaceable></term>
     <listitem>
      <para>
       Una duración que coincide con la expresión regular <literal>[0-9]+(ms-[smhdsa])</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELNAME</replaceable></term>
     <listitem>
      <para>
       Una cadena que coincide con la expresión regular <literal>[a-zA-Z_][a-zA-Z0-9_]*</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELVALUE</replaceable></term>
     <listitem>
      <para>
       Una cadena de caracteres Unicode.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>FILEPATH</replaceable></term>
     <listitem>
      <para>
       Una vía válida del directorio de trabajo actual.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>BOOLEAN</replaceable></term>
     <listitem>
      <para>
       Un valor booleano que puede tomar los valores "true" o "false".
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>STRING</replaceable></term>
     <listitem>
      <para>
       Una cadena normal.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>SECRET</replaceable></term>
     <listitem>
      <para>
       Una cadena normal que es un secreto; por ejemplo, una contraseña.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_STRING</replaceable></term>
     <listitem>
      <para>
       Una cadena que se expande con una plantilla antes de su uso.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_SECRET</replaceable></term>
     <listitem>
      <para>
       Una cadena de secreto que se expande con una plantilla antes de su uso.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <example>
    <title>Configuración global</title>
    <para>
     Los parámetros de la configuración <literal>global:</literal> son válidos en todos los demás contextos de configuración. También sirven como valores por defecto para otras secciones de la configuración.
    </para>
<screen>
global:
# the time after which an alert is declared resolved if it has not been updated
[ resolve_timeout: <replaceable>DURATION</replaceable> | default = 5m ]

# The default SMTP From header field.
[ smtp_from: <replaceable>TMPL_STRING</replaceable> ]
# The default SMTP smarthost used for sending emails, including port number.
# Port number usually is 25, or 587 for SMTP over TLS
# (sometimes referred to as STARTTLS).
# Example: smtp.example.org:587
[ smtp_smarthost: <replaceable>STRING</replaceable> ]
# The default host name to identify to the SMTP server.
[ smtp_hello: <replaceable>STRING</replaceable> | default = "localhost" ]
[ smtp_auth_username: <replaceable>STRING</replaceable> ]
# SMTP Auth using LOGIN and PLAIN.
[ smtp_auth_password: <replaceable>SECRET</replaceable> ]
# SMTP Auth using PLAIN.
[ smtp_auth_identity: <replaceable>STRING</replaceable> ]
# SMTP Auth using CRAM-MD5.
[ smtp_auth_secret: <replaceable>SECRET</replaceable> ]
# The default SMTP TLS requirement.
[ smtp_require_tls: <replaceable>BOOL</replaceable> | default = true ]

# The API URL to use for Slack notifications.
[ slack_api_url: <replaceable>STRING</replaceable> ]
[ victorops_api_key: <replaceable>STRING</replaceable> ]
[ victorops_api_url: <replaceable>STRING</replaceable> | default = "https://victorops.example.com/integrations/alert/" ]
[ pagerduty_url: <replaceable>STRING</replaceable> | default = "https://pagerduty.example.com/v2/enqueue" ]
[ opsgenie_api_key: <replaceable>STRING</replaceable> ]
[ opsgenie_api_url: <replaceable>STRING</replaceable> | default = "https://opsgenie.example.com/" ]
[ hipchat_api_url: <replaceable>STRING</replaceable> | default = "https://hipchat.example.com/" ]
[ hipchat_auth_token: <replaceable>SECRET</replaceable> ]
[ wechat_api_url: <replaceable>STRING</replaceable> | default = "https://wechat.example.com/cgi-bin/" ]
[ wechat_api_secret: <replaceable>SECRET</replaceable> ]
[ wechat_api_corp_id: <replaceable>STRING</replaceable> ]

# The default HTTP client configuration
[ http_config: <replaceable>HTTP_CONFIG</replaceable> ]

# Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - <replaceable>FILEPATH</replaceable> ... ]

# The root node of the routing tree.
route: <replaceable>ROUTE</replaceable>

# A list of notification receivers.
receivers:
- <replaceable>RECEIVER</replaceable> ...

# A list of inhibition rules.
inhibit_rules:
[ - <replaceable>INHIBIT_RULE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>ROUTE</replaceable></title>
    <para>
     Un bloque <replaceable>ROUTE</replaceable> define un nodo de un árbol de enrutamiento. Los parámetros que no se especifican, se heredan de su nodo padre. Cada alerta entra en el árbol de enrutamiento en la ruta de nivel superior configurada, que debe coincidir con todas las alertas. A continuación, recorre los nodos hijos. Si el valor de la opción <option>continue</option> es "false·, el recorrido se detiene después del primer elemento secundario que coincida. Si se establece el valor "true" en un nodo que coincida, la alerta seguirá coincidiendo con los hijos posteriores. Si una alerta no coincide con ningún hijo de un nodo, la alerta se controla en función de los parámetros de configuración del nodo actual.
    </para>
<screen>
[ receiver: <replaceable>STRING</replaceable> ]
[ group_by: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]

# If an alert should continue matching subsequent sibling nodes.
[ continue: <replaceable>BOOLEAN</replaceable> | default = false ]

# A set of equality matchers an alert has to fulfill to match a node.
match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]

# A set of regex-matchers an alert has to fulfill to match a node.
match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Time to wait before sending a notification for a group of alerts.
[ group_wait: <replaceable>DURATION</replaceable> | default = 30s ]

# Time to wait before sending a notification about new alerts
# added to a group of alerts for which an initial notification has
# already been sent.
[ group_interval: <replaceable>DURATION</replaceable> | default = 5m ]

# Time to wait before re-sending a notification
[ repeat_interval: <replaceable>DURATION</replaceable> | default = 4h ]

# Possible child routes.
routes:
 [ - <replaceable>ROUTE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>INHIBIT_RULE</replaceable></title>
    <para>
     Una regla de inhibición silencia una alerta de destino que coincide con un conjunto de coincidencias si existe una alerta de origen que coincida con otro conjunto de coincidencias. Ambas alertas deben compartir los mismos valores de etiqueta para los nombres de etiqueta en la lista <option>equal</option>.
    </para>
    <para>
     Las alertas pueden coincidir y, por lo tanto, inhibirse a sí mismas. No escriba reglas de inhibición si una alerta coincide tanto con el origen como con el destino.
    </para>
<screen>
# Matchers that need to be fulfilled for the alerts to be muted.
target_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
target_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Matchers for which at least one alert needs to exist so that the
# inhibition occurs.
source_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
source_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Labels with an equal value in the source and target
# alert for the inhibition to take effect.
[ equal: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]
</screen>
   </example>
   <example>
    <title><replaceable>HTTP_CONFIG</replaceable></title>
    <para>
     <replaceable>HTTP_CONFIG</replaceable> sirve para configurar el cliente HTTP utilizado por el receptor para comunicarse con los servicios de API.
    </para>
    <para>
     Tenga en cuenta que las opciones <option>basic_auth</option>, <option>bearer_token</option> y <option>bearer_token_file</option> son mutuamente excluyentes.
    </para>
<screen>
# Sets the 'Authorization' header with the user name and password.
basic_auth:
[ username: <replaceable>STRING</replaceable> ]
[ password: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token.
[ bearer_token: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token read from a file.
[ bearer_token_file: <replaceable>FILEPATH</replaceable> ]

# TLS settings.
tls_config:
# CA certificate to validate the server certificate with.
[ ca_file: <replaceable>FILEPATH</replaceable> ]
# Certificate and key files for client cert authentication to the server.
[ cert_file: <replaceable>FILEPATH</replaceable> ]
[ key_file: <replaceable>FILEPATH</replaceable> ]
# ServerName extension to indicate the name of the server.
# http://tools.ietf.org/html/rfc4366#section-3.1
[ server_name: <replaceable>STRING</replaceable> ]
# Disable validation of the server certificate.
[ insecure_skip_verify: <replaceable>BOOLEAN</replaceable> | default = false]

# Optional proxy URL.
[ proxy_url: <replaceable>STRING</replaceable> ]
</screen>
   </example>
   <example>
    <title><replaceable>RECEIVER</replaceable></title>
    <para>
     Un receptor es una configuración con nombre para una o más integraciones de notificación.
    </para>
    <para>
     En lugar de añadir nuevos receptores, se recomienda implementar integraciones de notificaciones personalizadas mediante el receptor de webhook (consulte el <xref linkend="alert-webhook"/>).
    </para>
<screen>
# The unique name of the receiver.
name: <replaceable>STRING</replaceable>

# Configurations for several notification integrations.
email_configs:
[ - <replaceable>EMAIL_CONFIG</replaceable>, ... ]
hipchat_configs:
[ - <replaceable>HIPCHAT_CONFIG</replaceable>, ... ]
pagerduty_configs:
[ - <replaceable>PAGERDUTY_CONFIG</replaceable>, ... ]
pushover_configs:
[ - <replaceable>PUSHOVER_CONFIG</replaceable>, ... ]
slack_configs:
[ - <replaceable>SLACK_CONFIG</replaceable>, ... ]
opsgenie_configs:
[ - <replaceable>OPSGENIE_CONFIG</replaceable>, ... ]
webhook_configs:
[ - <replaceable>WEBHOOK_CONFIG</replaceable>, ... ]
victorops_configs:
[ - <replaceable>VICTOROPS_CONFIG</replaceable>, ... ]
wechat_configs:
[ - <replaceable>WECHAT_CONFIG</replaceable>, ... ]
</screen>
   </example>
   <example>
    <title><replaceable>EMAIL_CONFIG</replaceable></title>
<screen>
# Whether to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The email address to send notifications to.
to: <replaceable>TMPL_STRING</replaceable>

# The sender address.
[ from: <replaceable>TMPL_STRING</replaceable> | default = global.smtp_from ]

# The SMTP host through which emails are sent.
[ smarthost: <replaceable>STRING</replaceable> | default = global.smtp_smarthost ]

# The host name to identify to the SMTP server.
[ hello: <replaceable>STRING</replaceable> | default = global.smtp_hello ]

# SMTP authentication details.
[ auth_username: <replaceable>STRING</replaceable> | default = global.smtp_auth_username ]
[ auth_password: <replaceable>SECRET</replaceable> | default = global.smtp_auth_password ]
[ auth_secret: <replaceable>SECRET</replaceable> | default = global.smtp_auth_secret ]
[ auth_identity: <replaceable>STRING</replaceable> | default = global.smtp_auth_identity ]

# The SMTP TLS requirement.
[ require_tls: <replaceable>BOOL</replaceable> | default = global.smtp_require_tls ]

# The HTML body of the email notification.
[ html: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "email.default.html" . }}' ]
# The text body of the email notification.
[ text: <replaceable>TMPL_STRING</replaceable> ]

# Further headers email header key/value pairs. Overrides any headers
# previously set by the notification implementation.
[ headers: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]
</screen>
   </example>
   <example>
    <title><replaceable>HIPCHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The HipChat Room ID.
room_id: <replaceable>TMPL_STRING</replaceable>
# The authentication token.
[ auth_token: <replaceable>SECRET</replaceable> | default = global.hipchat_auth_token ]
# The URL to send API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.hipchat_api_url ]

# A label to be shown in addition to the sender's name.
[ from:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.from" . }}' ]
# The message body.
[ message:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.message" . }}' ]
# Whether this message will trigger a user notification.
[ notify:  <replaceable>BOOLEAN</replaceable> | default = false ]
# Determines how the message is treated by the alertmanager and rendered inside HipChat. Valid values are 'text' and 'html'.
[ message_format:  <replaceable>STRING</replaceable> | default = 'text' ]
# Background color for message.
[ color:  <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}red{{ else }}green{{ end }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PAGERDUTY_CONFIG</replaceable></title>
    <para>
     Las opciones <option>routing_key</option> y <option>service_key</option> son mutuamente excluyentes.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The PagerDuty integration key (when using 'Events API v2').
routing_key: <replaceable>TMPL_SECRET</replaceable>
# The PagerDuty integration key (when using 'Prometheus').
service_key: <replaceable>TMPL_SECRET</replaceable>

# The URL to send API requests to.
[ url: <replaceable>STRING</replaceable> | default = global.pagerduty_url ]

# The client identification of the Alertmanager.
[ client:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.client" . }}' ]
# A backlink to the notification sender.
[ client_url:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.clientURL" . }}' ]

# The incident description.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.description" .}}' ]

# Severity of the incident.
[ severity: <replaceable>TMPL_STRING</replaceable> | default = 'error' ]

# A set of arbitrary key/value pairs that provide further details.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } | default = {
 firing:       '{{ template "pagerduty.default.instances" .Alerts.Firing }}'
 resolved:     '{{ template "pagerduty.default.instances" .Alerts.Resolved }}'
 num_firing:   '{{ .Alerts.Firing | len }}'
 num_resolved: '{{ .Alerts.Resolved | len }}'
} ]

# The HTTP client's configuration.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PUSHOVER_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The recipient user key.
user_key: <replaceable>SECRET</replaceable>

# Registered application’s API token.
token: <replaceable>SECRET</replaceable>

# Notification title.
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.title" . }}' ]

# Notification message.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.message" . }}' ]

# A supplementary URL displayed together with the message.
[ url: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.url" . }}' ]

# Priority.
[ priority: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}2{{ else }}0{{ end }}' ]

# How often the Pushover servers will send the same notification (at least 30 seconds).
[ retry: <replaceable>DURATION</replaceable> | default = 1m ]

# How long your notification will continue to be retried (unless the user
# acknowledges the notification).
[ expire: <replaceable>DURATION</replaceable> | default = 1h ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The Slack webhook URL.
[ api_url: <replaceable>SECRET</replaceable> | default = global.slack_api_url ]

# The channel or user to send notifications to.
channel: <replaceable>TMPL_STRING</replaceable>

# API request data as defined by the Slack webhook API.
[ icon_emoji: <replaceable>TMPL_STRING</replaceable> ]
[ icon_url: <replaceable>TMPL_STRING</replaceable> ]
[ link_names: <replaceable>BOOLEAN</replaceable> | default = false ]
[ username: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.username" . }}' ]
# The following parameters define the attachment.
actions:
[ <replaceable>ACTION_CONFIG</replaceable> ... ]
[ color: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}danger{{ else }}good{{ end }}' ]
[ fallback: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.fallback" . }}' ]
fields:
[ <replaceable>FIELD_CONFIG</replaceable> ... ]
[ footer: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.footer" . }}' ]
[ pretext: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.pretext" . }}' ]
[ short_fields: <replaceable>BOOLEAN</replaceable> | default = false ]
[ text: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.text" . }}' ]
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.title" . }}' ]
[ title_link: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.titlelink" . }}' ]
[ image_url: <replaceable>TMPL_STRING</replaceable> ]
[ thumb_url: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>ACTION_CONFIG</replaceable> para <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Provide a button to tell Slack you want to render a button.
type: <replaceable>TMPL_STRING</replaceable>
# Label for the button.
text: <replaceable>TMPL_STRING</replaceable>
# http or https URL to deliver users to. If you specify invalid URLs, the message will be posted with no button.
url: <replaceable>TMPL_STRING</replaceable>
#  If set to 'primary', the button will be green, indicating the best forward action to take
#  'danger' turns the button red, indicating a destructive action.
[ style: <replaceable>TMPL_STRING</replaceable> [ default = '' ]
</screen>
   </example>
   <example>
    <title><replaceable>FIELD_CONFIG</replaceable> para <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# A bold heading without markup above the <option>value</option> text.
title: <replaceable>TMPL_STRING</replaceable>
# The text of the field. It can span across several lines.
value: <replaceable>TMPL_STRING</replaceable>
# A flag indicating if <option>value</option> is short enough to be displayed together with other values.
[ short: <replaceable>BOOLEAN</replaceable> | default = slack_config.short_fields ]
</screen>
   </example>
   <example>
    <title><replaceable>OPSGENIE_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key to use with the OpsGenie API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.opsgenie_api_key ]

# The host to send OpsGenie API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.opsgenie_api_url ]

# Alert text (maximum is 130 characters).
[ message: <replaceable>TMPL_STRING</replaceable> ]

# A description of the incident.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.description" . }}' ]

# A backlink to the sender.
[ source: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.source" . }}' ]

# A set of arbitrary key/value pairs that provide further detail.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]

# Comma separated list of team responsible for notifications.
[ teams: <replaceable>TMPL_STRING</replaceable> ]

# Comma separated list of tags attached to the notifications.
[ tags: <replaceable>TMPL_STRING</replaceable> ]

# Additional alert note.
[ note: <replaceable>TMPL_STRING</replaceable> ]

# Priority level of alert, one of P1, P2, P3, P4, and P5.
[ priority: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>VICTOROPS_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key for talking to the VictorOps API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.victorops_api_key ]

# The VictorOps API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.victorops_api_url ]

# A key used to map the alert to a team.
routing_key: <replaceable>TMPL_STRING</replaceable>

# Describes the behavior of the alert (one of 'CRITICAL', 'WARNING', 'INFO').
[ message_type: <replaceable>TMPL_STRING</replaceable> | default = 'CRITICAL' ]

# Summary of the alerted problem.
[ entity_display_name: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.entity_display_name" . }}' ]

# Long explanation of the alerted problem.
[ state_message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.state_message" . }}' ]

# The monitoring tool the state message is from.
[ monitoring_tool: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.monitoring_tool" . }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example xml:id="alert-webhook">
    <title><replaceable>WEBHOOK_CONFIG</replaceable></title>
    <para>
     Puede utilizar el receptor de webhook para configurar un receptor genérico.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The endpoint for sending HTTP POST requests.
url: <replaceable>STRING</replaceable>

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
    <para>
     Alertmanager envía peticiones HTTP POST con el siguiente formato JSON:
    </para>
<screen>
{
 "version": "4",
 "groupKey": <replaceable>STRING</replaceable>, // identifycation of the group of alerts (to deduplicate)
 "status": "&lt;resolved|firing&gt;",
 "receiver": <replaceable>STRING</replaceable>,
 "groupLabels": <replaceable>OBJECT</replaceable>,
 "commonLabels": <replaceable>OBJECT</replaceable>,
 "commonAnnotations": <replaceable>OBJECT</replaceable>,
 "externalURL": <replaceable>STRING</replaceable>, // backlink to Alertmanager.
 "alerts": [
   {
     "status": "&lt;resolved|firing&gt;",
     "labels": <replaceable>OBJECT</replaceable>,
     "annotations": <replaceable>OBJECT</replaceable>,
     "startsAt": "&lt;rfc3339&gt;",
     "endsAt": "&lt;rfc3339&gt;",
     "generatorURL": <replaceable>STRING</replaceable> // identifies the entity that caused the alert
   },
   ...
 ]
}
</screen>
    <para>
     El receptor de webhook permite la integración con los siguientes mecanismos de notificación:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       DingTalk (https://github.com/timonwong/prometheus-webhook-dingtalk)
      </para>
     </listitem>
     <listitem>
      <para>
       Bot de IRC (https://github.com/multimfi/bot)
      </para>
     </listitem>
     <listitem>
      <para>
       JIRAlert (https://github.com/free/jiralert)
      </para>
     </listitem>
     <listitem>
      <para>
       Phabricator/Maniphest (https://github.com/knyar/phalerts)
      </para>
     </listitem>
     <listitem>
      <para>
       prom2teams: reenvía notificaciones a los equipos de Microsoft (https://github.com/idealista/prom2teams)
      </para>
     </listitem>
     <listitem>
      <para>
       SMS: admite varios proveedores (https://github.com/messagebird/sachet)
      </para>
     </listitem>
     <listitem>
      <para>
       Bot de Telegram (https://github.com/inCaller/prometheus_bot)
      </para>
     </listitem>
     <listitem>
      <para>
       Alerta SNMP (https://github.com/SUSE/prometheus-webhook-snmp)
      </para>
     </listitem>
    </itemizedlist>
   </example>
   <example>
    <title><replaceable>WECHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The API key to use for the WeChat API.
[ api_secret: <replaceable>SECRET</replaceable> | default = global.wechat_api_secret ]

# The WeChat API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.wechat_api_url ]

# The corp id used to authenticate.
[ corp_id: <replaceable>STRING</replaceable> | default = global.wechat_api_corp_id ]

# API request data as defined by the WeChat API.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "wechat.default.message" . }}' ]
[ agent_id: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.agent_id" . }}' ]
[ to_user: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_user" . }}' ]
[ to_party: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_party" . }}' ]
[ to_tag: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_tag" . }}' ]
</screen>
   </example>
  </sect2>
  <sect2>
   <title>Alertas personalizadas</title>
   <para>
    Puede definir las condiciones de alerta personalizadas para enviar notificaciones a un servicio externo. Prometheus utiliza su propio lenguaje de expresión para definir alertas personalizadas. A continuación se muestra un ejemplo de una regla con una alerta:
   </para>
<screen>
groups:
- name: example
 rules:
  # alert on high deviation from average PG count
  - alert: high pg count deviation
   expr: abs(((ceph_osd_pgs &gt; 0) - on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) / on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) &gt; 0.35
   for: 5m
   labels:
    severity: warning
    type: ses_default
   annotations:
   description: &gt;
    OSD {{ $labels.osd }} deviates by more then 30% from average PG count
</screen>
   <para>
    La cláusula opcional <literal>for</literal> especifica el tiempo que Prometheus esperará entre la primera vez que encuentre un elemento vectorial de salida de expresión nuevo y que cuente que una alerta se ha desencadenado. En este caso, Prometheus comprobará que la alerta continúa activa durante 5 minutos antes de desencadenar la alerta. Los elementos en estado pendiente están activos, pero aún no se han desencadenado.
   </para>
   <para>
    La cláusula <literal>labels</literal> especifica un conjunto de etiquetas adicionales adjuntas a la alerta. Las etiquetas en conflicto se sustituirán. Es posible crear una plantilla para las etiquetas (consulte la <xref linkend="alertmanager-templates"/> para obtener más detalles sobre la plantillas).
   </para>
   <para>
    La cláusula <literal>annotations</literal> especifica etiquetas informativas. Puede usarlas para almacenar información adicional, por ejemplo, descripciones de alertas o vínculos de runbook. Es posible crear una plantilla para las anotaciones (consulte la <xref linkend="alertmanager-templates"/> para obtener más detalles sobre la plantillas).
   </para>
   <para>
    Para añadir sus alertas personalizadas a SUSE Enterprise Storage 6:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      puede colocar sus archivos YAML con alertas personalizadas en el directorio <filename>/etc/prometheus/alerts</filename>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    o bien
   </para>
   <itemizedlist>
    <listitem>
     <para>
      proporcionar una lista de vías a los archivos de alerta personalizados del pilar en la clave <option>monitoring:custom_alerts</option>. Los archivos de alerta se añadirán en el lugar adecuado en la fase 2 de DeepSea o con el comando <command>salt <replaceable>MASTER_DE_SALT</replaceable> state.apply ceph.monitoring.prometheus</command>.
     </para>
     <example>
      <title>Adición de alertas personalizadas a SUSE Enterprise Storage</title>
      <para>
       Hay un archivo con alertas personalizadas en <filename>/root/my_alerts/my_alerts.yml</filename> en el master de Salt. Si añade
      </para>
<screen>
monitoring:
 custom_alerts:
   - /root/my_alerts/my_alerts.yml
</screen>
      <para>
       al archivo <filename>/srv/pillar/ceph/cluster/<replaceable>ID_DE_MINION_DE_SU_MASTER_DE_SALT</replaceable>.sls</filename>, DeepSea creará el archivo <filename>/etc/prometheus/alerts/my_alerts.yml</filename> y reiniciará Prometheus.
      </para>
     </example>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="alertmanager-templates">
    <title>Plantillas</title>
    <para>
     Puede utilizar plantillas para los valores de las etiquetas y las anotaciones. La variable <varname>$labels</varname> incluye los pares clave/valor de etiqueta de una instancia de alerta, mientras que <varname>$value</varname> contiene el valor evaluado de una instancia de alerta.
    </para>
    <para>
     En el ejemplo siguiente, se inserta una etiqueta y un valor de elemento de desencadenado:
    </para>
<screen>
{{ $labels.<replaceable>LABELNAME</replaceable> }}
{{ $value }}
</screen>
   </sect3>
   <sect3>
    <title>Inspección de alertas en el tiempo de ejecución</title>
    <para>
     Si necesita verificar qué alertas están activas, tiene varias opciones:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Diríjase a la pestaña <guimenu>Alerts</guimenu> (Alertas) de Prometheus. Allí se muestran los conjuntos de etiquetas exactos para los que hay activas alertas definidas. Prometheus también almacena series temporales sintéticas para las alertas pendientes y desencadenadas. Tienen el siguiente formato:
      </para>
<screen>
ALERTS{alertname="<replaceable>ALERT_NAME</replaceable>", alertstate="pending|firing", <replaceable>ADDITIONAL_ALERT_LABELS</replaceable>}
</screen>
      <para>
       El valor de muestra es 1 si la alerta está activa (pendiente o desencadenada). La serie se marca como "obsoleta" si la alerta está inactiva.
      </para>
     </listitem>
     <listitem>
      <para>
       En la interfaz Web de Prometheus, en la URL http://<replaceable>IP_DE_HOST_DE_PROMETHEUS</replaceable>:9090/alerts, inspeccione las alertas y su estado (INACTIVAS, PENDIENTES o DESENCADENADAS).
      </para>
     </listitem>
     <listitem>
      <para>
       En la interfaz Web de Alertmanager, en la URL http://<replaceable>IP_DE_HOST_DE_PROMETHEUS</replaceable>9093/alerts, inspeccione las alertas y siléncielas si lo desea.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>
  <sect2>
   <title>Receptor de alerta SNMP</title>
   <para>
    Si desea recibir una notificación sobre las alertas de Prometheus mediante alertas SNMP, puede instalar el receptor de alertas SNMP de Alertmanager de Prometheus a través de DeepSea. Para ello, debe habilitarlo en el pilar, en la clave <option>monitoring:alertmanager_receiver_snmp:enabled</option>. La configuración del receptor se debe establecer en la clave <option>monitoring:alertmanager_receiver_snmp:config</option>. El receptor se instalará y se configurará en la ubicación adecuada en la fase 2 de DeepSea o mediante el comando <command>salt <replaceable>MASTER_DE_SALT</replaceable> state.apply ceph.monitoring.alertmanager</command>.
   </para>
   <example>
    <title>Configuración de alerta SNMP</title>
<screen>
monitoring:
 alertmanager:
   receiver:
      snmp:
        enabled: True
        config:
          host: localhost
          port: 9099
          snmp_host: snmp.foo-bar.com
          snmp_community: private
          metrics: True
</screen>
     <para>
      Consulte el manual del receptor en <link xlink:href="https://github.com/SUSE/prometheus-webhook-snmp#global-configuration-file"/> para obtener más detalles sobre las opciones de configuración.
     </para>
    </example>
  </sect2>
</sect1>

</chapter>
