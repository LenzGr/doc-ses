<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_monitoring_alerting.xml" version="5.0" xml:id="monitoring-alerting">
 <title>Monitoraggio e creazione di avvisi</title>
 <para>
  In SUSE Enterprise Storage 6, DeepSea non distribuisce più uno stack di monitoraggio e creazione di avvisi sul Salt master. Gli utenti devono definire il ruolo Prometheus per Prometheus e Alertmanager e il ruolo Grafana per Grafana. Quando si assegnano più nodi con ruolo Prometheus o Grafana, viene distribuita una configurazione ad alta disponibilità.
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">Prometheus</emphasis> è il kit di strumenti per la creazione di avvisi e il monitoraggio.
   </para>
 </listitem>
 <listitem>
  <para>
   <emphasis role="bold">Alertmanager</emphasis> gestisce gli avvisi inviati dal server Prometheus.
  </para>
 </listitem>
  <listitem>
   <para>
    <emphasis role="bold">Grafana</emphasis> è il software di visualizzazione e creazione di avvisi.
   </para>
  </listitem>
  <listitem>
   <para>
    Il <systemitem class="daemon">prometheus-node_exporter</systemitem> è il servizio in esecuzione su tutti i Salt minion.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  La configurazione di Prometheus e le destinazioni di <emphasis>scrape</emphasis> (esportazione daemon) vengono impostate automaticamente da DeepSea. DeepSea inoltre distribuisce un elenco di avvisi di default, ad esempio <literal>health error</literal>, <literal>10% OSDs down</literal> o <literal>pgs inactive</literal>.
 </para>

 <sect1 xml:id="pillar-variables">
  <title>Variabili del pillar</title>
  <para>Il pillar di Salt è un archivio di chiavi-valori che fornisce informazioni e valori di configurazione ai minion. È disponibile per tutti i minion, con contenuti differenti per ciascuno. Il pillar di Salt è precompilato con valori di default e può essere personalizzato in due modi diversi:</para>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/global.yml</filename></emphasis>: per modificare le variabili del pillar per tutti i nodi.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/<replaceable>CLUSTER_NAME</replaceable>/minions/<replaceable>HOST</replaceable></filename></emphasis>: per modificare le configurazioni di specifici minion.
     </para>
    </listitem>
   </itemizedlist>
  <para>
    Le seguenti variabili del pillar sono disponibili di default per tutti i nodi:
  </para>
<screen>
  monitoring:
  alertmanager:
    config: salt://path/to/config
    additional_flags: ''
  grafana:
    ssl_cert: False # self-signed certs are created by default
    ssl_key: False # self-signed certs are created by default
  prometheus:
    # pass additional configration to prometheus
    additional_flags: ''
    alert_relabel_config: []
    rule_files: []
    # per exporter config variables
    scrape_interval:
      ceph: 10
      node_exporter: 10
      prometheus: 10
      grafana: 10
    relabel_config:
      alertmanager: []
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    metric_relabel_config:
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    target_partition:
      ceph: '1/1'
      node_exporter: '1/1'
      prometheus: '1/1'
      grafana: '1/1'
</screen>
</sect1>

<sect1 xml:id="grafana">
  <title>Grafana</title>
  <para>
    Tutto il traffico è cifrato tramite Grafana. È possibile fornire i propri certificati SSL o crearne uno autofirmato.</para>
  <para>Grafana utilizza le seguenti variabili:</para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_cert</literal></emphasis>
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_key</literal></emphasis>
      </para>
    </listitem>
  </itemizedlist>
  <para>Per ulteriori informazioni su come fornire i propri certificati SSL, consultare la <xref linkend="cert-sign-CA"/>; per sapere come creare un certificato autofirmato, consultare la <xref linkend="self-sign-certificates"/>.
  </para>
</sect1>

 <sect1 xml:id="prometheus">
   <title>Prometheus</title>
  <para>La configurazione basata sull'utilità di esportazione che può essere trasmessa tramite il pillar. Questi gruppi effettuano la mappatura alle utilità di esportazione che forniscono dati. L'utilità di esportazione del nodo è presente su tutti i nodi; Ceph viene esportato dai nodi Ceph Manager, mentre Prometheus e Grafana vengono esportati dai rispettivi nodi Prometheus e Grafana.</para>
  <para>Prometheus utilizza le seguenti variabili:</para>
    <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><literal>scrape_interval</literal></emphasis>: consente di modificare l'intervallo di scrape, ossia la frequenza con cui un'utilità di esportazione deve essere sottoposta a scrape.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>target_partition</literal></emphasis>: consente di partizionare le destinazioni di scrape quando vengono distribuite più istanze di Prometheus e alcune istanze effettuano lo scrape solo di una parte di tutte le istanze dell'utilità di esportazione.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>relabel_config</literal></emphasis>: consente di riscrivere dinamicamente il gruppo di etichette di una destinazione prima che venga sottoposta a scrape. Per ogni configurazione di scrape, è possibile configurare più fasi di rietichettatura.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>metrics_relabel_config</literal></emphasis>: applicata ai campioni come ultimo passaggio prima dell'acquisizione.
     </para>
    </listitem>
   </itemizedlist>
 </sect1>

 <sect1 xml:id="alerting-alertmanager">
  <title>Alertmanager</title>
  <para>
   Alertmanager gestisce gli avvisi inviati dal server Prometheus. Si occupa di deduplicarli, raggrupparli e instradarli al ricevitore corretto. Si incarica anche della disattivazione degli avvisi. Alertmanager è configurato tramite i flag della riga di comando e un file di configurazione che definisce le regole di inibizione, nonché l'instradamento e i ricevitori delle notifiche.
  </para>
  <sect2>
   <title>File di configurazione</title>
   <para>
    La configurazione di Alertmanager è differente per ogni distribuzione. Pertanto, DeepSea non fornisce alcun valore di default correlato. È necessario fornire il proprio file di configurazione <filename>alertmanager.yml</filename>. Il pacchetto
    <package>alertmanager</package> per default installa un file di configurazione <filename>/etc/prometheus/alertmanager.yml</filename> che può fungere da esempio di configurazione. Se si preferisce che sia DeepSea a gestire la configurazione di Alertmanager, aggiungere la chiave seguente al proprio pillar, ad esempio nel file <filename>/srv/pillar/ceph/stack/ceph/minions/<replaceable>YOUR_SALT_MASTER_MINION_ID</replaceable>.sls</filename>:
   </para>
   <para>
    Per un esempio completo del file di configurazione di Alertmanager, consultare l'<xref linkend="app-alerting-default"/>.
   </para>
<screen>
monitoring:
 alertmanager_config:
   /path/to/your/alertmanager/config.yml
</screen>
   <para>
    Il file di configurazione di Alertmanager è scritto in formato YAML e segue lo schema descritto di seguito. I parametri tra parentesi sono facoltativi. Per i parametri non di tipo elenco viene utilizzato il valore di default. Nello schema vengono utilizzati i seguenti segnaposto generici:
   </para>
   <variablelist>
    <varlistentry>
     <term><replaceable>DURATION</replaceable></term>
     <listitem>
      <para>
       Una durata corrispondente all'espressione regolare <literal>[0-9]+(ms|[smhdwy])</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELNAME</replaceable></term>
     <listitem>
      <para>
       Una stringa corrispondente all'espressione regolare <literal>[a-zA-Z_][a-zA-Z0-9_]*</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELVALUE</replaceable></term>
     <listitem>
      <para>
       Una stringa di caratteri Unicode.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>FILEPATH</replaceable></term>
     <listitem>
      <para>
       Un percorso valido nella directory di lavoro attuale.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>BOOLEAN</replaceable></term>
     <listitem>
      <para>
       Un valore booleano che può assumere i valori "true" o "false".
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>STRING</replaceable></term>
     <listitem>
      <para>
       Una normale stringa.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>SECRET</replaceable></term>
     <listitem>
      <para>
       Una normale stringa che rappresenta un segreto, ad esempio una password.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_STRING</replaceable></term>
     <listitem>
      <para>
       Una stringa ampliata in base a un modello prima dell'uso.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_SECRET</replaceable></term>
     <listitem>
      <para>
       Una stringa segreta ampliata in base a un modello prima dell'uso.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <example>
    <title>Configurazione globale</title>
    <para>
     I parametri nella configurazione <literal>global:</literal> sono validi in tutti gli altri contesti di configurazione. Fungono inoltre da default per altre sezioni di configurazione.
    </para>
<screen>
global:
# the time after which an alert is declared resolved if it has not been updated
[ resolve_timeout: <replaceable>DURATION</replaceable> | default = 5m ]

# The default SMTP From header field.
[ smtp_from: <replaceable>TMPL_STRING</replaceable> ]
# The default SMTP smarthost used for sending emails, including port number.
# Port number usually is 25, or 587 for SMTP over TLS
# (sometimes referred to as STARTTLS).
# Example: smtp.example.org:587
[ smtp_smarthost: <replaceable>STRING</replaceable> ]
# The default host name to identify to the SMTP server.
[ smtp_hello: <replaceable>STRING</replaceable> | default = "localhost" ]
[ smtp_auth_username: <replaceable>STRING</replaceable> ]
# SMTP Auth using LOGIN and PLAIN.
[ smtp_auth_password: <replaceable>SECRET</replaceable> ]
# SMTP Auth using PLAIN.
[ smtp_auth_identity: <replaceable>STRING</replaceable> ]
# SMTP Auth using CRAM-MD5.
[ smtp_auth_secret: <replaceable>SECRET</replaceable> ]
# The default SMTP TLS requirement.
[ smtp_require_tls: <replaceable>BOOL</replaceable> | default = true ]

# The API URL to use for Slack notifications.
[ slack_api_url: <replaceable>STRING</replaceable> ]
[ victorops_api_key: <replaceable>STRING</replaceable> ]
[ victorops_api_url: <replaceable>STRING</replaceable> | default = "https://victorops.example.com/integrations/alert/" ]
[ pagerduty_url: <replaceable>STRING</replaceable> | default = "https://pagerduty.example.com/v2/enqueue" ]
[ opsgenie_api_key: <replaceable>STRING</replaceable> ]
[ opsgenie_api_url: <replaceable>STRING</replaceable> | default = "https://opsgenie.example.com/" ]
[ hipchat_api_url: <replaceable>STRING</replaceable> | default = "https://hipchat.example.com/" ]
[ hipchat_auth_token: <replaceable>SECRET</replaceable> ]
[ wechat_api_url: <replaceable>STRING</replaceable> | default = "https://wechat.example.com/cgi-bin/" ]
[ wechat_api_secret: <replaceable>SECRET</replaceable> ]
[ wechat_api_corp_id: <replaceable>STRING</replaceable> ]

# The default HTTP client configuration
[ http_config: <replaceable>HTTP_CONFIG</replaceable> ]

# Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - <replaceable>FILEPATH</replaceable> ... ]

# The root node of the routing tree.
route: <replaceable>ROUTE</replaceable>

# A list of notification receivers.
receivers:
- <replaceable>RECEIVER</replaceable> ...

# A list of inhibition rules.
inhibit_rules:
[ - <replaceable>INHIBIT_RULE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>ROUTE</replaceable></title>
    <para>
     Un blocco <replaceable>ROUTE</replaceable> definisce un nodo in un albero di instradamento. I parametri non specificati vengono ereditati dal nodo superiore. Ogni avviso fa il proprio ingresso nell'albero di instradamento in corrispondenza dell'instradamento di livello superiore configurato, che deve corrispondere a tutti gli avvisi. Successivamente, attraversa i nodi secondari. Se l'opzione <option>continue</option> è impostata su "false", l'attraversamento si interrompe dopo il primo nodo secondario corrispondente. Impostando l'opzione su "true" su un nodo corrispondente, l'avviso continua la ricerca della corrispondenza sui nodi affini successivi. Se non trova corrispondenza con alcun nodo secondario, l'avviso viene gestito in base ai parametri di configurazione del nodo attuale.
    </para>
<screen>
[ receiver: <replaceable>STRING</replaceable> ]
[ group_by: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]

# If an alert should continue matching subsequent sibling nodes.
[ continue: <replaceable>BOOLEAN</replaceable> | default = false ]

# A set of equality matchers an alert has to fulfill to match a node.
match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]

# A set of regex-matchers an alert has to fulfill to match a node.
match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Time to wait before sending a notification for a group of alerts.
[ group_wait: <replaceable>DURATION</replaceable> | default = 30s ]

# Time to wait before sending a notification about new alerts
# added to a group of alerts for which an initial notification has
# already been sent.
[ group_interval: <replaceable>DURATION</replaceable> | default = 5m ]

# Time to wait before re-sending a notification
[ repeat_interval: <replaceable>DURATION</replaceable> | default = 4h ]

# Possible child routes.
routes:
 [ - <replaceable>ROUTE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>INHIBIT_RULE</replaceable></title>
    <para>
     Una regola di inibizione disattiva un avviso di destinazione corrispondente a un gruppo di matcher quando esiste un avviso di origine corrispondente a un altro gruppo di matcher. Entrambi gli avvisi devono condividere gli stessi valori di etichetta per i nomi di etichetta nell'elenco <option>equal</option>.
    </para>
    <para>
     Gli avvisi possono corrispondere e quindi disabilitarsi a vicenda. Evitare di scrivere regole di inibizione in cui un avviso corrisponde sia all'origine che alla destinazione.
    </para>
<screen>
# Matchers that need to be fulfilled for the alerts to be muted.
target_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
target_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Matchers for which at least one alert needs to exist so that the
# inhibition occurs.
source_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
source_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Labels with an equal value in the source and target
# alert for the inhibition to take effect.
[ equal: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]
</screen>
   </example>
   <example>
    <title><replaceable>HTTP_CONFIG</replaceable></title>
    <para>
     <replaceable>HTTP_CONFIG</replaceable> consente di configurare il client HTTP utilizzato dal ricevitore per comunicare con i servizi API.
    </para>
    <para>
     Si noti che le opzioni <option>basic_auth</option>, <option>bearer_token</option> e <option>bearer_token_file</option> sono mutualmente esclusive.
    </para>
<screen>
# Sets the 'Authorization' header with the user name and password.
basic_auth:
[ username: <replaceable>STRING</replaceable> ]
[ password: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token.
[ bearer_token: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token read from a file.
[ bearer_token_file: <replaceable>FILEPATH</replaceable> ]

# TLS settings.
tls_config:
# CA certificate to validate the server certificate with.
[ ca_file: <replaceable>FILEPATH</replaceable> ]
# Certificate and key files for client cert authentication to the server.
[ cert_file: <replaceable>FILEPATH</replaceable> ]
[ key_file: <replaceable>FILEPATH</replaceable> ]
# ServerName extension to indicate the name of the server.
# http://tools.ietf.org/html/rfc4366#section-3.1
[ server_name: <replaceable>STRING</replaceable> ]
# Disable validation of the server certificate.
[ insecure_skip_verify: <replaceable>BOOLEAN</replaceable> | default = false]

# Optional proxy URL.
[ proxy_url: <replaceable>STRING</replaceable> ]
</screen>
   </example>
   <example>
    <title><replaceable>RECEIVER</replaceable></title>
    <para>
     Il ricevitore è una configurazione con nome per una o più integrazioni di notifica.
    </para>
    <para>
     Anziché aggiungere nuovi ricevitori, si consiglia di implementare integrazioni di notifica personalizzate utilizzando il ricevitore webhook (consultare l'<xref linkend="alert-webhook"/>).
    </para>
<screen>
# The unique name of the receiver.
name: <replaceable>STRING</replaceable>

# Configurations for several notification integrations.
email_configs:
[ - <replaceable>EMAIL_CONFIG</replaceable>, ... ]
hipchat_configs:
[ - <replaceable>HIPCHAT_CONFIG</replaceable>, ... ]
pagerduty_configs:
[ - <replaceable>PAGERDUTY_CONFIG</replaceable>, ... ]
pushover_configs:
[ - <replaceable>PUSHOVER_CONFIG</replaceable>, ... ]
slack_configs:
[ - <replaceable>SLACK_CONFIG</replaceable>, ... ]
opsgenie_configs:
[ - <replaceable>OPSGENIE_CONFIG</replaceable>, ... ]
webhook_configs:
[ - <replaceable>WEBHOOK_CONFIG</replaceable>, ... ]
victorops_configs:
[ - <replaceable>VICTOROPS_CONFIG</replaceable>, ... ]
wechat_configs:
[ - <replaceable>WECHAT_CONFIG</replaceable>, ... ]
</screen>
   </example>
   <example>
    <title><replaceable>EMAIL_CONFIG</replaceable></title>
<screen>
# Whether to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The email address to send notifications to.
to: <replaceable>TMPL_STRING</replaceable>

# The sender address.
[ from: <replaceable>TMPL_STRING</replaceable> | default = global.smtp_from ]

# The SMTP host through which emails are sent.
[ smarthost: <replaceable>STRING</replaceable> | default = global.smtp_smarthost ]

# The host name to identify to the SMTP server.
[ hello: <replaceable>STRING</replaceable> | default = global.smtp_hello ]

# SMTP authentication details.
[ auth_username: <replaceable>STRING</replaceable> | default = global.smtp_auth_username ]
[ auth_password: <replaceable>SECRET</replaceable> | default = global.smtp_auth_password ]
[ auth_secret: <replaceable>SECRET</replaceable> | default = global.smtp_auth_secret ]
[ auth_identity: <replaceable>STRING</replaceable> | default = global.smtp_auth_identity ]

# The SMTP TLS requirement.
[ require_tls: <replaceable>BOOL</replaceable> | default = global.smtp_require_tls ]

# The HTML body of the email notification.
[ html: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "email.default.html" . }}' ]
# The text body of the email notification.
[ text: <replaceable>TMPL_STRING</replaceable> ]

# Further headers email header key/value pairs. Overrides any headers
# previously set by the notification implementation.
[ headers: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]
</screen>
   </example>
   <example>
    <title><replaceable>HIPCHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The HipChat Room ID.
room_id: <replaceable>TMPL_STRING</replaceable>
# The authentication token.
[ auth_token: <replaceable>SECRET</replaceable> | default = global.hipchat_auth_token ]
# The URL to send API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.hipchat_api_url ]

# A label to be shown in addition to the sender's name.
[ from:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.from" . }}' ]
# The message body.
[ message:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.message" . }}' ]
# Whether this message will trigger a user notification.
[ notify:  <replaceable>BOOLEAN</replaceable> | default = false ]
# Determines how the message is treated by the alertmanager and rendered inside HipChat. Valid values are 'text' and 'html'.
[ message_format:  <replaceable>STRING</replaceable> | default = 'text' ]
# Background color for message.
[ color:  <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}red{{ else }}green{{ end }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PAGERDUTY_CONFIG</replaceable></title>
    <para>
     Le opzioni <option>routing_key</option> e <option>service_key</option> si escludono a vicenda.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The PagerDuty integration key (when using 'Events API v2').
routing_key: <replaceable>TMPL_SECRET</replaceable>
# The PagerDuty integration key (when using 'Prometheus').
service_key: <replaceable>TMPL_SECRET</replaceable>

# The URL to send API requests to.
[ url: <replaceable>STRING</replaceable> | default = global.pagerduty_url ]

# The client identification of the Alertmanager.
[ client:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.client" . }}' ]
# A backlink to the notification sender.
[ client_url:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.clientURL" . }}' ]

# The incident description.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.description" .}}' ]

# Severity of the incident.
[ severity: <replaceable>TMPL_STRING</replaceable> | default = 'error' ]

# A set of arbitrary key/value pairs that provide further details.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } | default = {
 firing:       '{{ template "pagerduty.default.instances" .Alerts.Firing }}'
 resolved:     '{{ template "pagerduty.default.instances" .Alerts.Resolved }}'
 num_firing:   '{{ .Alerts.Firing | len }}'
 num_resolved: '{{ .Alerts.Resolved | len }}'
} ]

# The HTTP client's configuration.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PUSHOVER_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The recipient user key.
user_key: <replaceable>SECRET</replaceable>

# Registered application’s API token.
token: <replaceable>SECRET</replaceable>

# Notification title.
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.title" . }}' ]

# Notification message.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.message" . }}' ]

# A supplementary URL displayed together with the message.
[ url: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.url" . }}' ]

# Priority.
[ priority: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}2{{ else }}0{{ end }}' ]

# How often the Pushover servers will send the same notification (at least 30 seconds).
[ retry: <replaceable>DURATION</replaceable> | default = 1m ]

# How long your notification will continue to be retried (unless the user
# acknowledges the notification).
[ expire: <replaceable>DURATION</replaceable> | default = 1h ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The Slack webhook URL.
[ api_url: <replaceable>SECRET</replaceable> | default = global.slack_api_url ]

# The channel or user to send notifications to.
channel: <replaceable>TMPL_STRING</replaceable>

# API request data as defined by the Slack webhook API.
[ icon_emoji: <replaceable>TMPL_STRING</replaceable> ]
[ icon_url: <replaceable>TMPL_STRING</replaceable> ]
[ link_names: <replaceable>BOOLEAN</replaceable> | default = false ]
[ username: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.username" . }}' ]
# The following parameters define the attachment.
actions:
[ <replaceable>ACTION_CONFIG</replaceable> ... ]
[ color: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}danger{{ else }}good{{ end }}' ]
[ fallback: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.fallback" . }}' ]
fields:
[ <replaceable>FIELD_CONFIG</replaceable> ... ]
[ footer: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.footer" . }}' ]
[ pretext: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.pretext" . }}' ]
[ short_fields: <replaceable>BOOLEAN</replaceable> | default = false ]
[ text: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.text" . }}' ]
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.title" . }}' ]
[ title_link: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.titlelink" . }}' ]
[ image_url: <replaceable>TMPL_STRING</replaceable> ]
[ thumb_url: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>ACTION_CONFIG</replaceable> per <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Provide a button to tell Slack you want to render a button.
type: <replaceable>TMPL_STRING</replaceable>
# Label for the button.
text: <replaceable>TMPL_STRING</replaceable>
# http or https URL to deliver users to. If you specify invalid URLs, the message will be posted with no button.
url: <replaceable>TMPL_STRING</replaceable>
#  If set to 'primary', the button will be green, indicating the best forward action to take
#  'danger' turns the button red, indicating a destructive action.
[ style: <replaceable>TMPL_STRING</replaceable> [ default = '' ]
</screen>
   </example>
   <example>
    <title><replaceable>FIELD_CONFIG</replaceable> per <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# A bold heading without markup above the <option>value</option> text.
title: <replaceable>TMPL_STRING</replaceable>
# The text of the field. It can span across several lines.
value: <replaceable>TMPL_STRING</replaceable>
# A flag indicating if <option>value</option> is short enough to be displayed together with other values.
[ short: <replaceable>BOOLEAN</replaceable> | default = slack_config.short_fields ]
</screen>
   </example>
   <example>
    <title><replaceable>OPSGENIE_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key to use with the OpsGenie API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.opsgenie_api_key ]

# The host to send OpsGenie API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.opsgenie_api_url ]

# Alert text (maximum is 130 characters).
[ message: <replaceable>TMPL_STRING</replaceable> ]

# A description of the incident.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.description" . }}' ]

# A backlink to the sender.
[ source: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.source" . }}' ]

# A set of arbitrary key/value pairs that provide further detail.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]

# Comma separated list of team responsible for notifications.
[ teams: <replaceable>TMPL_STRING</replaceable> ]

# Comma separated list of tags attached to the notifications.
[ tags: <replaceable>TMPL_STRING</replaceable> ]

# Additional alert note.
[ note: <replaceable>TMPL_STRING</replaceable> ]

# Priority level of alert, one of P1, P2, P3, P4, and P5.
[ priority: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>VICTOROPS_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key for talking to the VictorOps API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.victorops_api_key ]

# The VictorOps API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.victorops_api_url ]

# A key used to map the alert to a team.
routing_key: <replaceable>TMPL_STRING</replaceable>

# Describes the behavior of the alert (one of 'CRITICAL', 'WARNING', 'INFO').
[ message_type: <replaceable>TMPL_STRING</replaceable> | default = 'CRITICAL' ]

# Summary of the alerted problem.
[ entity_display_name: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.entity_display_name" . }}' ]

# Long explanation of the alerted problem.
[ state_message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.state_message" . }}' ]

# The monitoring tool the state message is from.
[ monitoring_tool: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.monitoring_tool" . }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example xml:id="alert-webhook">
    <title><replaceable>WEBHOOK_CONFIG</replaceable></title>
    <para>
     È possibile utilizzare il ricevitore webhook per configurare un ricevitore generico.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The endpoint for sending HTTP POST requests.
url: <replaceable>STRING</replaceable>

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
    <para>
     Alertmanager invia richieste HTTP POST nel seguente formato JSON:
    </para>
<screen>
{
 "version": "4",
 "groupKey": <replaceable>STRING</replaceable>, // identifycation of the group of alerts (to deduplicate)
 "status": "&lt;resolved|firing&gt;",
 "receiver": <replaceable>STRING</replaceable>,
 "groupLabels": <replaceable>OBJECT</replaceable>,
 "commonLabels": <replaceable>OBJECT</replaceable>,
 "commonAnnotations": <replaceable>OBJECT</replaceable>,
 "externalURL": <replaceable>STRING</replaceable>, // backlink to Alertmanager.
 "alerts": [
   {
     "status": "&lt;resolved|firing&gt;",
     "labels": <replaceable>OBJECT</replaceable>,
     "annotations": <replaceable>OBJECT</replaceable>,
     "startsAt": "&lt;rfc3339&gt;",
     "endsAt": "&lt;rfc3339&gt;",
     "generatorURL": <replaceable>STRING</replaceable> // identifies the entity that caused the alert
   },
   ...
 ]
}
</screen>
    <para>
     Il ricevitore webhook consente l'integrazione con i seguenti meccanismi di notifica:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       DingTalk (https://github.com/timonwong/prometheus-webhook-dingtalk)
      </para>
     </listitem>
     <listitem>
      <para>
       Bot IRC (https://github.com/multimfi/bot)
      </para>
     </listitem>
     <listitem>
      <para>
       JIRAlert (https://github.com/free/jiralert)
      </para>
     </listitem>
     <listitem>
      <para>
       Phabricator / Maniphest (https://github.com/knyar/phalerts)
      </para>
     </listitem>
     <listitem>
      <para>
       prom2teams: inoltra le notifiche a Microsoft Teams (https://github.com/idealista/prom2teams)
      </para>
     </listitem>
     <listitem>
      <para>
       SMS: supporta più provider (https://github.com/messagebird/sachet)
      </para>
     </listitem>
     <listitem>
      <para>
       Bot Telegram (https://github.com/inCaller/prometheus_bot)
      </para>
     </listitem>
     <listitem>
      <para>
       Trap SNMP (https://github.com/SUSE/prometheus-webhook-snmp)
      </para>
     </listitem>
    </itemizedlist>
   </example>
   <example>
    <title><replaceable>WECHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The API key to use for the WeChat API.
[ api_secret: <replaceable>SECRET</replaceable> | default = global.wechat_api_secret ]

# The WeChat API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.wechat_api_url ]

# The corp id used to authenticate.
[ corp_id: <replaceable>STRING</replaceable> | default = global.wechat_api_corp_id ]

# API request data as defined by the WeChat API.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "wechat.default.message" . }}' ]
[ agent_id: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.agent_id" . }}' ]
[ to_user: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_user" . }}' ]
[ to_party: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_party" . }}' ]
[ to_tag: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_tag" . }}' ]
</screen>
   </example>
  </sect2>
  <sect2>
   <title>Avvisi personalizzati</title>
   <para>
    È possibile definire condizioni di avviso personalizzate per l'invio di notifiche a un servizio esterno. Prometheus utilizza un proprio linguaggio di espressioni per definire gli avvisi personalizzati. Di seguito è riportato un esempio di regola con un avviso:
   </para>
<screen>
groups:
- name: example
 rules:
  # alert on high deviation from average PG count
  - alert: high pg count deviation
   expr: abs(((ceph_osd_pgs &gt; 0) - on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) / on (job) group_left avg(ceph_osd_pgs &gt; 0) by (job)) &gt; 0.35
   for: 5m
   labels:
    severity: warning
    type: ses_default
   annotations:
   description: &gt;
    OSD {{ $labels.osd }} deviates by more then 30% from average PG count
</screen>
   <para>
    La clausola opzionale <literal>for</literal> specifica il tempo di attesa da parte di Prometheus tra il primo rilevamento di un nuovo elemento vettore di output espressione e il conteggio di un avviso come in fase di emissione. In questo caso, Prometheus verifica che l'avviso continui a essere attivo per 5 minuti prima di emetterlo. Gli elementi in sospeso sono attivi, ma non sono ancora in fase di emissione.
   </para>
   <para>
    La clausola <literal>labels</literal> specifica un gruppo di etichette aggiuntive allegate all'avviso. Se sono in conflitto, vengono sovrascritte. Le etichette possono essere basate su un modello (per maggiori dettagli sulla definizione in base a un modello, consultare la <xref linkend="alertmanager-templates"/>).
   </para>
   <para>
    La clausola <literal>annotations</literal> specifica le etichette informative. È possibile utilizzarle per memorizzare informazioni aggiuntive, come le descrizioni degli avvisi o i collegamenti a runbook. Le annotazioni possono essere basate su un modello (per maggiori dettagli sulla definizione in base a un modello, consultare la <xref linkend="alertmanager-templates"/>).
   </para>
   <para>
    Per aggiungere i propri avvisi personalizzati a SUSE Enterprise Storage 6,
   </para>
   <itemizedlist>
    <listitem>
     <para>
      posizionare i file YAML con avvisi personalizzati nella directory <filename>/etc/prometheus/alerts</filename>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    oppure
   </para>
   <itemizedlist>
    <listitem>
     <para>
      fornire un elenco di percorsi ai file con avvisi personalizzati nel Pillar utilizzando la chiave <option>monitoring:custom_alerts</option>. DeepSea Stage 2 o il comando <command>salt <replaceable>SALT_MASTER</replaceable> state.apply ceph.monitoring.prometheus</command> aggiunge i file di avviso nella posizione corretta.
     </para>
     <example>
      <title>Aggiunta di avvisi personalizzati a SUSE Enterprise Storage</title>
      <para>
       Nel Salt master è presente un file con avvisi personalizzati in <filename>/root/my_alerts/my_alerts.yml</filename>. Se si aggiunge
      </para>
<screen>
monitoring:
 custom_alerts:
   - /root/my_alerts/my_alerts.yml
</screen>
      <para>
       al file <filename>/srv/pillar/ceph/cluster/<replaceable>YOUR_SALT_MASTER_MINION_ID</replaceable>.sls</filename>, DeepSea crea il file <filename>/etc/prometheus/alerts/my_alerts.yml</filename> e riavvia Prometheus.
      </para>
     </example>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="alertmanager-templates">
    <title>Modelli</title>
    <para>
     È possibile utilizzare modelli per i valori di annotazioni ed etichette. La variabile
     <varname>$labels</varname> Include le coppie chiave/valore etichetta di un'istanza di avviso, mentre <varname>$value</varname> contiene il valore sottoposto a valutazione di un'istanza di avviso.
    </para>
    <para>
     Il seguente esempio inserisce il valore e l'etichetta di un elemento in fase di emissione:
    </para>
<screen>
{{ $labels.<replaceable>LABELNAME</replaceable> }}
{{ $value }}
</screen>
   </sect3>
   <sect3>
    <title>Ispezione degli avvisi al runtime</title>
    <para>
     Se è necessario verificare quali avvisi sono attivi, sono disponibili diverse opzioni:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Andare alla scheda <guimenu>Alerts</guimenu> di Prometheus. La scheda mostra i gruppi di etichette esatti per i quali sono attivi gli avvisi definiti. Inoltre, Prometheus memorizza le serie temporali sintetiche per gli avvisi in sospeso e in fase di emissione. Le serie hanno il seguente formato:
      </para>
<screen>
ALERTS{alertname="<replaceable>ALERT_NAME</replaceable>", alertstate="pending|firing", <replaceable>ADDITIONAL_ALERT_LABELS</replaceable>}
</screen>
      <para>
       Il valore di esempio è 1 se l'avviso è attivo (in sospeso o in fase di emissione). La serie è contrassegnata con "stale" se l'avviso è inattivo.
      </para>
     </listitem>
     <listitem>
      <para>
       Nell'interfaccia web di Prometheus, all'indirizzo URL http://<replaceable>PROMETHEUS_HOST_IP</replaceable>:9090/alerts, ispezionare gli avvisi e il relativo stato (INACTIVE, PENDING o FIRING).
      </para>
     </listitem>
     <listitem>
      <para>
       Nell'interfaccia web di Alertmanager, all'indirizzo URL http://:<replaceable>PROMETHEUS_HOST_IP</replaceable>9093/#/alerts, ispezionare gli avvisi e, se necessario, disattivarli.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>
  <sect2>
   <title>Ricevitore delle trap SNMP</title>
   <para>
    Se si desidera ricevere notifiche sugli avvisi di Prometheus tramite trap SNMP, è possibile installare il ricevitore di trap SNMP Prometheus Alertmanager tramite DeepSea. A tale scopo, è necessario abilitarlo utilizzando la chiave <option>monitoring:alertmanager_receiver_snmp:enabled</option>. La configurazione del ricevitore deve essere impostata utilizzando la chiave <option>monitoring:alertmanager_receiver_snmp:config</option>. DeepSea Stage 2 o il comando <command>salt <replaceable>SALT_MASTER</replaceable> state.apply ceph.monitoring.alertmanager</command> installano e configurano il ricevitore nella posizione appropriata.
   </para>
   <example>
    <title>Configurazione delle trap SNMP</title>
<screen>
monitoring:
 alertmanager:
   receiver:
      snmp:
        enabled: True
        config:
          host: localhost
          port: 9099
          snmp_host: snmp.foo-bar.com
          snmp_community: private
          metrics: True
</screen>
     <para>
      Fare riferimento al manuale del ricevitore all'indirizzo <link xlink:href="https://github.com/SUSE/prometheus-webhook-snmp#global-configuration-file"/>. per maggiori dettagli sulle opzioni di configurazione.
     </para>
    </example>
  </sect2>
</sect1>

</chapter>
